using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace ITVComponents.Decisions
{
    public class SimpleDecider<T>:IDecider<T> where T:class 
    {
        /// <summary>
        /// Holds all deciders for this SimpleDecider
        /// </summary>
        private List<IConstraint<T>> constraints = new List<IConstraint<T>>();

        /// <summary>
        /// Provides a local context that can be used to provide context-driven values for constraints
        /// </summary>
        [NonSerialized]
        private ThreadLocal<SimpleContext<T>> contextBuilder;

        /// <summary>
        /// Initialiezs a new instance of the SimpleDecider class
        /// </summary>
        /// <param name="contextDriven">Indicates whether this SimpleDecider object should work context-driven</param>
        public SimpleDecider(bool contextDriven)
        {
            IsContextDriven = contextDriven;
            if (contextDriven)
            {
                contextBuilder = new ThreadLocal<SimpleContext<T>>();
            }
        }

        /// <summary>
        /// The DeciderContext providing data of Deciders for past decisions
        /// </summary>
        IDeciderContext IDecider.Context => Context;

        /// <summary>
        /// The DeciderContext providing data of Deciders for past decisions
        /// </summary>
        public IDeciderContext<T> Context
        {
            get
            {
                IDeciderContext<T> retVal = null;
                if (IsContextDriven)
                {
                    if (!contextBuilder.IsValueCreated || contextBuilder.Value == null)
                    {
                        contextBuilder.Value = new SimpleContext<T>();
                    }

                    retVal = contextBuilder.Value;
                }

                return retVal;
            }
        }

        #region Implementation of IDecider<T>

        /// <summary>
        /// Gets a value indicating whether this Decider instance is Context driven, so that Constraints can Store data when using a Decision-chain
        /// </summary>
        public bool IsContextDriven { get; }

        /// <summary>
        /// Flushes all Context-bound values of this Decider
        /// </summary>
        public void FlushContext()
        {
            if (IsContextDriven && contextBuilder.IsValueCreated && contextBuilder.Value != null)
            {
                IFlushableContext flusher = contextBuilder.Value;
                flusher.Flush();
                contextBuilder.Value = null;
            }
        }

        /// <summary>
        /// Adds a constraint to the list of available constraints
        /// </summary>
        /// <param name="constraint">a Constraint that needs to be processed when calling the Decide-Method</param>
        public void AddConstraint(IConstraint<T> constraint)
        {
            constraint.SetParent(this);
            constraints.Add(constraint);
        }

        /// <summary>
        /// Adds a constraint to the list of available constraints
        /// </summary>
        /// <param name="constraint">a Constraint that needs to be processed when calling the Decide-Method</param>
        void IDecider.AddConstraint(IConstraint constraint)
        {
            AddConstraint((IConstraint<T>) constraint);
        }

        /// <summary>
        /// Evaluates the provided data with the available constraints
        /// </summary>
        /// <param name="value">the provided data</param>
        /// <param name="method">the used decider-method.</param>
        /// <param name="messages">the messages that were generated by the attached constraints</param>
        /// <returns>a value indicating whether the provided data meets the criteria of this Decider or not</returns>
        DecisionResult IDecider.Decide(object value, DecisionMethod method, out string messages)
        {
            return Decide((T) value, method, out messages);
        }

        /// <summary>
        /// Evaluates the provided data with the available constraints
        /// </summary>
        /// <param name="value">the provided data</param>
        /// <param name="method">the used decider-method.</param>
        /// <param name="messages">the messages that were generated by the attached constraints</param>
        /// <returns>a value indicating whether the provided data meets the criteria of this Decider or not</returns>
        public DecisionResult Decide(T value, DecisionMethod method, out string messages)
        {
            StringBuilder msg = new StringBuilder();
            DecisionResult retVal = constraints.Count == 0 ? DecisionResult.Success : DecisionResult.None;
            foreach (IConstraint<T> constraint in constraints)
            {
                string message;
                DecisionResult result = constraint.Verify(value, out message);
                retVal |= result;
                if ((((result & (DecisionResult.Success | DecisionResult.Acceptable)) != DecisionResult.None) && ((method & DecisionMethod.FullSuccessMessagesOnly) != 0)) ||
                    (((result & DecisionResult.Fail) != DecisionResult.None) && ((method & DecisionMethod.FullSuccessMessagesOnly) != 0)))
                {
                    if (!string.IsNullOrEmpty(message))
                    {
                        msg.AppendLine(message);
                    }
                }

                if (((retVal & DecisionResult.Fail) == DecisionResult.Fail) && method == DecisionMethod.Simple)
                {
                    break;
                }
            }

            messages = msg.ToString(0, msg.Length > 0 ? msg.Length - Environment.NewLine.Length : 0);
            return retVal;
        }

        /// <summary>Returns a string that represents the current object.</summary>
        /// <returns>A string that represents the current object.</returns>
        /// <filterpriority>2</filterpriority>
        public override string ToString()
        {
            return $@"Constraints:
{string.Join("\r\n",from t in constraints select t.ToString())}
Constraints are evaluated {(!IsContextDriven ? "Context-free " : "Context-driven")}.";
        }

        /// <summary>
        /// Offers the Possibility to perform Tasks during serialization of this instance
        /// </summary>
        /// <param name="context">the streaming-context</param>
        protected virtual void Serializing(StreamingContext context)
        {
        }

        /// <summary>
        /// Offers the possibility to perform Tasks during the Deserialization of this instance
        /// </summary>
        /// <param name="context">the streaming-context</param>
        protected virtual void Deserializing(StreamingContext context)
        {
            contextBuilder = new ThreadLocal<SimpleContext<T>>();
        }

        /// <summary>
        /// Offers the possibility to perform Tasks after the deserialization of this instance
        /// </summary>
        /// <param name="context">the streaming-context</param>
        protected virtual void Deserialized(StreamingContext context)
        {
        }

        /// <summary>
        /// Handles the Serialization of this instance
        /// </summary>
        /// <param name="context">the streaming-context of this instance</param>
        [OnSerializing]
        private void OnSerializing(StreamingContext context)
        {
            Serializing(context);
        }

        /// <summary>
        /// Handles the Deserializing of this instance
        /// </summary>
        /// <param name="context">the streamingcontext of this instance</param>
        [OnDeserializing]
        private void OnDeserializing(StreamingContext context)
        {
            Deserializing(context);
        }

        /// <summary>
        /// Handles the post-deserializing of this instance
        /// </summary>
        /// <param name="context">the streamingcontext of this instance</param>
        [OnDeserialized]
        private void OnDeserialized(StreamingContext context)
        {
            Deserialized(context);
        }
        #endregion
    }
}
