using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Security.Principal;
using System.Text;
using System.Threading.Tasks;
using ITVComponents.Helpers;
using ITVComponents.InterProcessCommunication.Shared.Helpers;
using ITVComponents.InterProcessCommunication.Shared.Proxying;
using ITVComponents.InterProcessCommunication.Shared.Security;
using ITVComponents.Logging;
using ITVComponents.Plugins;
using ITVComponents.Scripting.CScript.Core.Methods;
using ITVComponents.Threading;

namespace ITVComponents.InterProcessCommunication.Shared.Base
{
    public abstract class BaseServer:IPlugin, IDeferredInit
    {
        /// <summary>
        /// A dictionary containing the names of loaded plugins
        /// </summary>
        protected readonly FactoryWrapper plugins;

        /// <summary>
        /// the next Id to assign to ae extended proxy
        /// </summary>
        private int nextProxyId = 0;

        /// <summary>
        /// Holds a list of extended proxies that are available for clients
        /// </summary>
        private Dictionary<string, ProxyWrapper> extendedProxies;

        /// <summary>
        /// A dictionary containing the subscribed events and their recipients
        /// </summary>
        private ConcurrentDictionary<string, List<string>> eventSubscriptions;

        /// <summary>
        /// A dictionary containing all sessions and their Status
        /// </summary>
        private ConcurrentDictionary<string, SessionStatus> sessions;

        /// <summary>
        /// an object used to synchronize objects used by asynchronous processes such as event (un-)subscriptions, propertie gets/sets and event raisings
        /// </summary>
        protected readonly object resourceLock;

        /// <summary>
        /// Gets or sets the UniqueName of this Plugin
        /// </summary>
        public string UniqueName { get; set; }

        /// <summary>
        /// The Owner - Name of all Threads that are generated by this proxy Service
        /// </summary>
        private string threadsOwner;

        private bool useExtendedProxying;
        private readonly ICustomServerSecurity serverSecurity;

        /// <summary>
        /// Initializes a new instance of the Server class
        /// </summary>
        protected BaseServer(PluginFactory factory, bool useExtendedProxying, bool useSecurity, ICustomServerSecurity security)
            : this()
        {
            this.useExtendedProxying = useExtendedProxying;
            this.serverSecurity = security;
            this.plugins = new FactoryWrapper(factory, extendedProxies, useSecurity);
        }

        /// <summary>
        /// Prevents a default instance of the Server class from being created
        /// </summary>
        private BaseServer()
        {
            //plugins = new ConcurrentDictionary<string, IPlugin>();
            extendedProxies = new Dictionary<string, ProxyWrapper>();
            resourceLock = new object();
            threadsOwner = string.Format("::{0}::", GetHashCode());
            eventSubscriptions = new ConcurrentDictionary<string, List<string>>();
            sessions = new ConcurrentDictionary<string, SessionStatus>();
        }

        /// <summary>
        /// Indicates whether this deferrable init-object is already initialized
        /// </summary>
        public bool Initialized { get; private set; }

        /// <summary>
        /// Indicates whether this Object requires immediate Initialization right after calling the constructor
        /// </summary>
        public bool ForceImmediateInitialization => false;

        /// <summary>
        /// Initializes this deferred initializable object
        /// </summary>
        public void Initialize()
        {
            if (!Initialized)
            {
                try
                {
                    ServiceInit();
                }
                finally
                {
                    Initialized = true;
                }
            }
        }

        /// <summary>
        /// Führt anwendungsspezifische Aufgaben durch, die mit der Freigabe, der Zurückgabe oder dem Zurücksetzen von nicht verwalteten Ressourcen zusammenhängen.
        /// </summary>
        /// <filterpriority>2</filterpriority>
        public virtual void Dispose()
        {
            Disposed?.Invoke(this, EventArgs.Empty);
        }

        /// <summary>
        /// Test method to check whether the pipe is still available
        /// </summary>
        /// <returns>true</returns>
        protected bool Test()
        {
            return true;
        }

        /// <summary>
        /// Gets a property on the provided object
        /// </summary>
        /// <param name="targetObject">the name of the targetobject from which to get a property</param>
        /// <param name="propertyName">the name of the property to read</param>
        /// <param name="index">the index required to read the property</param>
        /// <returns>the value of the requested property</returns>
        protected object GetProperty(string targetObject, string propertyName, object[] index, IIdentity authenticatedUser)
        {
            targetObject.LocalOwner(threadsOwner);
            index = ResolveBuffers(index);
            try
            {
                if (propertyName != "")
                {
                    PropertyInfo pfo = GetPropertyInfo(targetObject, propertyName, BindingFlags.GetProperty);
                    string reason = null;
                    if (!(serverSecurity?.VerifyAccess(pfo, targetObject, null, authenticatedUser, false, out reason) ?? true))
                    {
                        throw new InterProcessException(reason, null);
                    }

                    object retVal = pfo.GetValue(plugins[targetObject], index);
                    if (pfo.PropertyType.IsInterface && useExtendedProxying)
                    {
                        retVal = GetBufferFor(retVal, pfo.PropertyType, authenticatedUser);
                    }

                    return retVal;
                }
                else
                {
                    PropertyInfo pfo = GetPropertyInfo(targetObject, index);
                    string reason = null;
                    if (!(serverSecurity?.VerifyAccess(pfo, targetObject, index, authenticatedUser, false, out reason) ?? true))
                    {
                        throw new InterProcessException(reason, null);
                    }

                    object retVal = pfo.GetValue(plugins[targetObject], index);
                    if (pfo.PropertyType.IsInterface && useExtendedProxying)
                    {
                        retVal = GetBufferFor(retVal, pfo.PropertyType, authenticatedUser);
                    }

                    return retVal;
                }
            }
            finally
            {
                targetObject.LocalOwner(null);
            }
        }

        /// <summary>
        /// Sets the value of a property on a target object
        /// </summary>
        /// <param name="targetObject">the target object on which to set a property</param>
        /// <param name="propertyName">the propertyname to set</param>
        /// <param name="index">the index used for indexed properties</param>
        /// <param name="value">the new value for the specified property</param>
        protected void SetProperty(string targetObject, string propertyName, object[] index, object value, IIdentity authenticatedUser)
        {
            targetObject.LocalOwner(threadsOwner);
            index = ResolveBuffers(index);
            var result = value as ProxyResult;
            if (result != null)
            {
                value = ResolveBuffer(result.UniqueName);
            }

            try
            {
                if (propertyName != "")
                {
                    PropertyInfo pfo = GetPropertyInfo(targetObject, propertyName, BindingFlags.SetProperty);
                    string reason = null;
                    if (!(serverSecurity?.VerifyAccess(pfo, targetObject, null, authenticatedUser, true, out reason) ?? true))
                    {
                        throw new InterProcessException(reason, null);
                    }

                    pfo.SetValue(plugins[targetObject], value, index);
                }
                else
                {
                    PropertyInfo pfo = GetPropertyInfo(targetObject, index);
                    string reason = null;
                    if (!(serverSecurity?.VerifyAccess(pfo, targetObject, index, authenticatedUser, true, out reason) ?? true))
                    {
                        throw new InterProcessException(reason, null);
                    }

                    pfo.SetValue(plugins[targetObject], value, index);
                }
            }
            finally
            {
                targetObject.LocalOwner(null);
            }
        }

        /// <summary>
        /// Disconnects the client and removes all event notifications subscribed for it
        /// </summary>
        protected void Quit()
        {
            RemoveClient();
        }

        /// <summary>
        /// Checks whether a specific object is loaded on the remote service
        /// </summary>
        /// <param name="uniqueObjectName">the unique name of the requested plugin</param>
        /// <returns>indicates wheter such an object exists in the service scope</returns>
        protected ObjectAvailabilityResult CheckForAvailableProxy(string uniqueObjectName, IIdentity authenticatedUser)
        {
            bool securityRequired;
            bool available = plugins.Contains(uniqueObjectName, out securityRequired);
            string reason = null;
            bool denied = securityRequired && available && !serverSecurity.VerifyAccess(uniqueObjectName, authenticatedUser, out reason);
            available &= !denied;
            return new ObjectAvailabilityResult
            {
                Available = available,
                Message = available ? "Object is available" : securityRequired ? (denied ? reason : "The requested object requires security. Consider using a different connection") : "The requested object does not exist"
            };
        }

        /// <summary>
        /// Removes an object on the Server for the given objectName. Works only for extended Proxy-objects
        /// </summary>
        /// <param name="uniqueObjectName">the objectName to remove from the list of extension.proxies</param>
        /// <returns>a value indicating whether the object could be removed successfully</returns>
        protected bool AbandonExtendedProxy(string uniqueObjectName, IIdentity authenticatedUser)
        {
            if (extendedProxies.ContainsKey(uniqueObjectName))
            {
                lock (extendedProxies)
                {
                    if (authenticatedUser == null || extendedProxies[uniqueObjectName].Owner == authenticatedUser)
                    return extendedProxies.Remove(uniqueObjectName);
                }
            }

            return false;
        }

        /// <summary>
        /// executes a method requested by a client
        /// </summary>
        /// <param name="targetObject">the name of the targetobject on which to execute the method</param>
        /// <param name="methodName">the name of the method to execute</param>
        /// <param name="arguments">the arguments for the method call</param>
        /// <param name="authenticatedUser">the user that was provided by the connector</param>
        /// <returns>the result of the method call</returns>
        protected ExecutionResult ExecuteMethod(string targetObject, string methodName, object[] arguments, IIdentity authenticatedUser)
        {
            lock (resourceLock)
            {
                targetObject.LocalOwner(threadsOwner);
                try
                {
                    bool securityRequired;
                    object obj = plugins.Contains(targetObject, out securityRequired) ? plugins[targetObject] : null;
                    if (obj == null)
                    {
                        if (!securityRequired)
                        {
                            throw new InterProcessException(string.Format("Server object with name {0} is not present",
                                targetObject), null);
                        }

                        throw new InterProcessException(
                            string.Format(
                                "Server object with name {0} requires Security. Please consider using a different Connector for access.",
                                targetObject), null);
                    }

                    Type typ = obj.GetType();
                    Type[] arrNu = GetTypeArray(arguments ?? new object[] { });
                    Type[] arrWu = GetTypeArray(arguments ?? new object[] { })
                        .Concat(new Type[] {typeof(IIdentity)})
                        .ToArray();
                    Type[] arrTp;
                    int ignoreParamCount = 0;
                    object[] nuArg = arguments.Select(n => n).ToArray();
                    object[] wuArg = arguments.Concat(new object[]{authenticatedUser}).ToArray();
                    bool isStatic = false;
                    MethodInfo infNu = MethodHelper.GetCapableMethod(typ, Type.EmptyTypes, methodName, ref isStatic, nuArg, out nuArg);
                    MethodInfo infWu = MethodHelper.GetCapableMethod(typ, Type.EmptyTypes, methodName, ref isStatic, wuArg, out wuArg);
                    MethodInfo targetMethod;
                    if ((infNu == null && infWu == null) || (authenticatedUser == null && infNu == null))
                    {
                        LogEnvironment.LogDebugEvent(null,
                            string.Format("Method {0} not found on {1}", methodName, targetObject), (int) LogSeverity.Warning, null);
                        throw new InvalidOperationException("Unable to run this method!");
                    }

                    ExecutionResult retVal = new ExecutionResult();
                    retVal.ActionName = methodName;
                    object[] param;
                    if (infNu != null && infWu == null)
                    {
                        param = nuArg;
                        arrTp = arrNu;
                        targetMethod = infNu;
                        UserDelegationAttribute delegation =
                            (UserDelegationAttribute)
                            Attribute.GetCustomAttribute(infNu, typeof(UserDelegationAttribute), true);
                        if (delegation != null)
                        {
                            targetObject.LocalConfiguration(delegation.ThreadSettingName, authenticatedUser);
                        }
                    }
                    else
                    {
                        param = wuArg;
                        arrTp = arrWu;
                        targetMethod = infWu;
                        ignoreParamCount = 1;
                    }

                    string reason = null;
                    if (!(serverSecurity?.VerifyAccess(targetMethod, targetObject, param, authenticatedUser, out reason) ?? true))
                    {
                        throw new InterProcessException(reason, null);
                    }

                    retVal.Result = targetMethod.Invoke(obj, param);
                    if (targetMethod.ReturnType.IsInterface && useExtendedProxying)
                    {
                        retVal.Result = GetBufferFor(retVal.Result, targetMethod.ReturnType, authenticatedUser);
                    }

                    retVal.Parameters = IntroduceProxies(param, arrTp, ignoreParamCount, authenticatedUser);

                    return retVal;
                }
                catch (InterProcessException ix)
                {
                    throw;
                }
                catch (TargetInvocationException tie)
                {
                    LogEnvironment.LogDebugEvent(null, tie.InnerException?.ToString(), (int) LogSeverity.Error, null);
                    throw new InterProcessException(tie.InnerException?.Message ?? tie.Message, tie.InnerException ?? tie);
                }
                catch (Exception ex)
                {
                    LogEnvironment.LogDebugEvent(null, ex.ToString(), (int)LogSeverity.Error, null);
                    throw new InterProcessException(ex.Message, ex);
                    //throw;
                }
                finally
                {
                    targetObject.LocalOwner(null);
                    targetObject.ClearLocalConfiguration();
                }
            }
        }

        /// <summary>
        /// Removes all subscriptions from a client object
        /// </summary>
        protected void RemoveClient()
        {
        }

        /// <summary>
        /// Adds an eventhandler for a specific event
        /// </summary>
        /// <param name="targetObject">the name of the target object on which to subscribe for an event</param>
        /// <param name="eventName">the event to subscribe for notifications</param>
        /// <returns>a value indicating whether the event subscription was successful</returns>
        protected bool SubscribeForEvent(string targetObject, string eventName, string sessionId, IIdentity authenticatedUser)
        {
            try
            {
                var status = sessions.GetOrAdd(sessionId, f => new SessionStatus
                {
                    SessionAlive = true,
                    SessionFunctional = true
                });
                if (status.SessionAlive)
                {
                    AddEventSubscription(targetObject, eventName,
                        sessionId, authenticatedUser);
                    if (!status.SessionFunctional)
                    {
                        LogEnvironment.LogDebugEvent($"Added Event-Subscription for the event {eventName} on the object {targetObject} for the session {sessionId}. However, the Event will not be fired, because the return-channel is currently not functional.", LogSeverity.Warning);
                    }

                    return true;
                }
            }
            catch (Exception ex)
            {
                ex.OutlineException();
            }

            return false;
        }

        /// <summary>
        /// Removes the subscription for a specific event on the remote service
        /// </summary>
        /// <param name="eventName">the event for which to remove the notification subscription</param>
        /// <returns>a value indicating whether the subscription removal was successful</returns>
        protected bool UnSubscribeEvent(string objectName, string eventName, string sessionId, IIdentity authenticatedUser)
        {
            bool retVal = false;
            try
            {
                string eventIdentifyer = string.Format("{0}_{1}", objectName, eventName);
                //OperationContext.Current.
                if (sessions.TryGetValue(sessionId, out var status))
                {
                    lock (resourceLock)
                    {
                        if (eventSubscriptions.ContainsKey(eventIdentifyer))
                        {
                            List<string> subscribers = eventSubscriptions[eventIdentifyer];
                            if (subscribers.Contains(sessionId))
                            {
                                subscribers.Remove(sessionId);
                                retVal = true;
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                LogEnvironment.LogEvent(string.Format(@"{0}
{1}",ex.Message,ex.StackTrace),LogSeverity.Error);
                retVal = false;
            }

            return retVal;
        }

        /// <summary>
        /// Raises an event on the client
        /// </summary>
        /// <param name="eventName">the name of the server-event</param>
        /// <param name="sessionId">the session for which to raise the event</param>
        /// <param name="arguments">the arguments for the raised event</param>
        protected abstract Task RaiseEvent(string eventName, string sessionId, object[] arguments);

        /// <summary>
        /// Invokes a test-method on the event-subscribing client
        /// </summary>
        /// <param name="sessionId">the session id for which to check whether the client is still present</param>
        /// <returns>a value indicating whether the client is still active</returns>
        protected abstract bool Test(string sessionId);

        /// <summary>
        /// Initializes this object to act as a ipc service
        /// </summary>
        protected abstract void ServiceInit();

        /// <summary>
        /// Gets the specified property of a specific object
        /// </summary>
        /// <param name="targetObject">the unique name of the target object</param>
        /// <param name="propertyName">the name of the property</param>
        /// <param name="memberFlag">a flag indicating whether the property must be readable or writeable</param>
        /// <returns>the propertyinfo of the demanded property</returns>
        private PropertyInfo GetPropertyInfo(string targetObject, string propertyName, BindingFlags memberFlag)
        {
            Type t = plugins[targetObject].GetType();
            return t.GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.FlattenHierarchy | memberFlag);
        }

        /// <summary>
        /// Gets the Index - Property that applies to the given indexer information
        /// </summary>
        /// <param name="targetObject">the targetobject</param>
        /// <param name="index">the index</param>
        /// <returns>the first propertyInfo, that fits the given conditions</returns>
        private PropertyInfo GetPropertyInfo(string targetObject, object[] index)
        {
            Type t = plugins[targetObject].GetType();
            Type[] methodTypes = GetTypes(index);
            return
                (from p in t.GetProperties() where ParametersAccepted(methodTypes, p.GetIndexParameters()) select p)
                    .First();
        }

        /// <summary>
        /// indicates whether the provided parameters are accepted by a method taking the given arguments
        /// </summary>
        /// <param name="types">the types that will be passed to the method</param>
        /// <param name="parameters">the method parameters</param>
        /// <returns>a value indicating whether the parameters will be accepted by the method</returns>
        private bool ParametersAccepted(Type[] types, ParameterInfo[] parameters)
        {
            bool retVal = parameters != null && types.Length == parameters.Length;
            if (retVal)
            {
                for (int i = 0; i < parameters.Length && retVal; i++)
                {
                    retVal &= parameters[i].ParameterType.IsAssignableFrom(types[i]);
                }
            }

            return retVal;
        }

        /// <summary>
        /// Gets the Type information array of parameters that must be passed to an indexer
        /// </summary>
        /// <param name="objects">the object array of the indexer-parameters</param>
        /// <returns>the types to pass to the index</returns>
        private Type[] GetTypes(object[] objects)
        {
            Type[] retVal = new Type[objects.Length];
            for (int i = 0; i < objects.Length; i++)
            {
                Type t = null;
                if (objects[i] != null)
                {
                    t = objects[i].GetType();
                }

                retVal[i] = t;
            }

            return retVal;
        }

        /// <summary>
        /// Creates an eventhandler for the specified event info
        /// </summary>
        /// <param name="info">the event information for the subscribed event</param>
        /// <param name="eventName">the event name</param>
        /// <returns>a delegate that raises a generic event providing all required information used to distribute the event to clients</returns>
        private Delegate CreateEventHandler(EventInfo info, string eventName)
        {
            Action<string, object[]> raiseEvent = RaiseEvent;
            Type method = info.EventHandlerType;
            ParameterInfo[] methodParameters = method.GetMethod("Invoke").GetParameters();
            List<string> names = new List<string>();
            int a = 0;
            ParameterExpression[] parameters = methodParameters.Select(n => Expression.Parameter(n.ParameterType, string.Format("arg{0}", a++))).ToArray();
            names.AddRange(parameters.Select(n => n.Name));
            NewArrayExpression array = Expression.NewArrayInit(typeof(object), parameters);
            LambdaExpression lambda = Expression.Lambda(Expression.Call(Expression.Constant(raiseEvent), typeof(Action<string, object[]>).GetMethod("Invoke"), Expression.Constant(eventName), array), parameters);
            Delegate tmp = lambda.Compile();
            return Delegate.CreateDelegate(method, tmp, "Invoke", false);
        }

        /// <summary>
        /// Adds an event subscription for a specific object
        /// </summary>
        /// <param name="objectName">the object for which to add an event subscription</param>
        /// <param name="eventName">the name of the subscribed event</param>
        /// <param name="callbackSession">the remote client that will receive the event notification</param>
        private void AddEventSubscription(string objectName, string eventName, string callbackSession, IIdentity authenticatedUser)
        {
            lock (resourceLock)
            {
                bool securityRequired;
                if (plugins.Contains(objectName, out securityRequired))
                {
                    string eventIdentifyer = string.Format("{0}_{1}", objectName, eventName);
                    if (!eventSubscriptions.ContainsKey(eventIdentifyer))
                    {
                        object o = plugins[objectName];
                        EventInfo d = GetEvent(objectName, eventName);
                        string reason = null;
                        if (!(serverSecurity?.VerifyAccess(d, objectName, authenticatedUser, out reason) ?? true))
                        {
                            throw new InterProcessException(reason, null);
                        }

                        Delegate del = CreateEventHandler(d, eventIdentifyer);
                        d.AddEventHandler(o, del);
                        eventSubscriptions.AddOrUpdate(eventIdentifyer, s => new List<string>(),
                                                       (s, ori) => new List<string>());
                    }

                    List<string> l;
                    lock (l = eventSubscriptions[eventIdentifyer])
                    {
                        if (!l.Contains(callbackSession))
                        {
                            l.Add(callbackSession);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Gets the specified event of a specific object
        /// </summary>
        /// <param name="targetObject">the unique name of the target object</param>
        /// <param name="eventName">the name of the event</param>
        /// <returns>an eventinfo of the demanded event</returns>
        private EventInfo GetEvent(string targetObject, string eventName)
        {
            Type t = plugins[targetObject].GetType();
            return t.GetEvent(eventName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.FlattenHierarchy);
        }

        /// <summary>
        /// Raises the specified event on all subscribing remote clients
        /// </summary>
        /// <param name="eventName">the event-name</param>
        /// <param name="arguments">all event arguments</param>
        private void RaiseEvent(string eventName, object[] arguments)
        {
            lock (resourceLock)
            {
                if (eventSubscriptions.ContainsKey(eventName))
                {
                    string[] callbackReceivers = eventSubscriptions[eventName].ToArray();
                    for (int i = 0; i < arguments.Length; i++)
                    {
                        try
                        {
                            if (arguments[i] is IPlugin)
                            {
                                arguments[i] = (arguments[i] as IPlugin).UniqueName;
                            }
                        }
                        catch (Exception ex)
                        {
                            LogEnvironment.LogDebugEvent(ex.OutlineException(), LogSeverity.Error);
                        }
                    }

                    foreach (string s in callbackReceivers)
                    {
                        try
                        {
                            var f =
                                new Action<SessionStatus, string, string, object[]>(
                                    async delegate(SessionStatus src, string sessionId, string srcEventName, object[] args)
                                    {
                                        bool ok;
#pragma warning disable 665
                                        // ReSharper disable once AssignmentInConditionalExpression
                                        if (ok = TestRemoteConnection(sessionId))
#pragma warning restore 665
                                        {
                                            try
                                            {
                                                await RaiseEvent(srcEventName, sessionId, args);
                                            }
                                            catch (Exception ex)
                                            {
                                                ok = false;
                                                LogEnvironment.LogEvent(ex.ToString(), LogSeverity.Error);
                                            }
                                        }

                                        if (!ok)
                                        {
                                            LogEnvironment.LogDebugEvent(
                                                "Raise-event failed.",
                                                LogSeverity.Warning);
                                            src.SessionFunctional = false;
                                            /*lock (eventSubscriptions[srcEventName])
                                            {
                                                eventSubscriptions[srcEventName].Remove(sessionId);
                                            }*/
                                        }
                                    });
                            if (sessions.TryGetValue(s, out var session))
                            {
                                if (session.SessionAlive && session.SessionFunctional)
                                {
                                    Task.Run(() => f(session, s, eventName, arguments));
                                }
                                else if (session.SessionAlive)
                                {
                                    LogEnvironment.LogDebugEvent($"The Event {eventName} will not be raised for the session {s}, becuase the reply-channel is currently not functioning. The Connection will be re-established soon.",LogSeverity.Warning);
                                    sessions.TryRemove(s, out _);
                                }
                            }
                        }
                        catch (Exception x)
                        {
                            LogEnvironment.LogEvent(x.OutlineException(), LogSeverity.Error);
                        }
                    }
                }
            }
        }

        private Type[] GetTypeArray(object[] args)
        {
            Type[] retVal = new Type[args.Length];
            for (int i = 0; i < retVal.Length; i++)
            {
                LogEnvironment.LogDebugEvent($"CurrentParameter: {i}, {args[i]?.GetType()}", LogSeverity.Report);
                if (args[i] != null && !(args[i] is TypedParam))
                {
                    var result = args[i] as ProxyResult;
                    if (result != null)
                    {
                        args[i] = ResolveBuffer(result.UniqueName);
                    }

                    retVal[i] = args[i].GetType();
                }
                else if (args[i] is TypedParam)
                {
                    retVal[i] = ((TypedParam) args[i]).NullType;
                    args[i] = ((TypedParam) args[i]).GetValue(ResolveBuffer);
                }
                else
                {
                    retVal[i] = typeof (object);
                }
            }

            return retVal;
        }

        /// <summary>
        /// Checks whether the remote object is still alive
        /// </summary>
        /// <param name="sessionId">the client object to test for validity</param>
        /// <returns>a value indicating whether the connection was successful</returns>
        private bool TestRemoteConnection(string sessionId)
        {
            bool retVal = false;
            try
            {
                retVal = Test(sessionId);
            }
            catch (Exception ex)
            {
                LogEnvironment.LogEvent(ex.Message,LogSeverity.Error);
            }

            return retVal;
        }

        private object[] ResolveBuffers(object[] values)
        {
            object[] retVal = new object[values.Length];
            for (int i = 0; i < retVal.Length; i++)
            {
                var result = values[i] as ProxyResult;
                if (result != null)
                {
                    retVal[i] = ResolveBuffer(result.UniqueName);
                }
            }

            return retVal;
        }

        private object ResolveBuffer(string name)
        {
            return plugins[name];
        }

        private ProxyResult GetBufferFor(object value, Type interfaceType, IIdentity owner)
        {
            ProxyResult r = new ProxyResult();
            string proxyName;
            lock (extendedProxies)
            {
                nextProxyId++;
                proxyName = $"proxy_{nextProxyId}_{DateTime.Now.Ticks}_{interfaceType.Name}";
                extendedProxies.Add(proxyName, new ProxyWrapper{Value=value, Owner = owner});
            }

            r.Type = interfaceType;
            r.UniqueName = proxyName;
            return r;
        }

        private object[] IntroduceProxies(object[] arguments, Type[] types, int ignoreParamCount, IIdentity owner)
        {
            object[] retVal = new object[types.Length-ignoreParamCount];
            for (int i = 0; i < retVal.Length; i++)
            {
                if (types[i].IsByRef)
                {
                    types[i] = types[i].GetElementType();
                    retVal[i] = arguments[i];
                    if (types[i].IsInterface && useExtendedProxying)
                    {
                        retVal[i] = GetBufferFor(retVal[i], types[i], owner);
                    }
                }
            }

            return retVal;
        }

        /// <summary>
        /// Informs a calling class of a Disposal of this Instance
        /// </summary>
        [field: NonSerialized]
        public event EventHandler Disposed;
    }
}
