using System;
using System.Collections.Concurrent;
using ITVComponents.InterProcessCommunication.Shared.Base;
using ITVComponents.InterProcessCommunication.Shared.Proxying;

namespace ITVComponents.InterProcessCommunication.Shared.Helpers
{
    public static class CustomProxy
    {
        private static ConcurrentDictionary<Type, Func<string, IBaseClient, IObjectProxy>> knownProxies = new ConcurrentDictionary<Type, Func<string, IBaseClient, IObjectProxy>>();

        /// <summary>
        /// Registers a Proxy-type for a given Interface type
        /// </summary>
        /// <param name="interfaceType">the interface type for which to customize the interface creation</param>
        /// <param name="creationCallback">the callback that is used to create the custom proxy</param>
        public static void RegisterProxy(Type interfaceType, Func<string, IBaseClient, IObjectProxy> creationCallback)
        {
            knownProxies.TryAdd(interfaceType, creationCallback);
        }

        /// <summary>
        /// Gets a value indicating whether the requested proxy exists
        /// </summary>
        /// <param name="type">the target type for which a proxy is requested</param>
        /// <returns>a value indicating whether the requested proxy is a custom implementation</returns>
        public static bool IsProxyAvailable(Type type)
        {
            return knownProxies.ContainsKey(type);
        }

        /// <summary>
        /// Gets a custom Proxy for the type T if a construction callback is available
        /// </summary>
        /// <typeparam name="T">the Type for which to create a custom proxy</typeparam>
        /// <param name="client">the client that is used to communicate with the remote object</param>
        /// <param name="uniqueName">the unique name of the remote object</param>
        /// <returns>the constructed proxy that was generated by the callback</returns>
        public static T GetCustomProxy<T>(IBaseClient client, string uniqueName)
        {
            if (IsProxyAvailable(typeof(T)))
            {
                return (T)GetCustomProxy(typeof(T), client, uniqueName);
            }

            return default(T);
        }

        /// <summary>
        /// Gets a custom Proxy for the type T if a construction callback is available
        /// </summary>
        /// <param name="t">the Type for which to create a custom proxy</param>
        /// <param name="client">the client that is used to communicate with the remote object</param>
        /// <param name="uniqueName">the unique name of the remote object</param>
        /// <returns>the constructed proxy that was generated by the callback</returns>
        public static IObjectProxy GetCustomProxy(Type t, IBaseClient client, string uniqueName)
        {
            Func<string, IBaseClient, IObjectProxy> callback;
            if (knownProxies.TryGetValue(t, out callback))
            {
                return callback(uniqueName, client);
            }

            return null;
        }
    }
}
