//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.10.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from ITVScripting.g4 by ANTLR 4.10.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace ITVComponents.Scripting.CScript.Core {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.10.1")]
[System.CLSCompliant(false)]
public partial class ITVScriptingParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, T__8=9, 
		T__9=10, T__10=11, T__11=12, T__12=13, T__13=14, T__14=15, T__15=16, T__16=17, 
		LineTerminator=18, OpenBracket=19, CloseBracket=20, OpenParen=21, CloseParen=22, 
		OpenBrace=23, CloseBrace=24, SemiColon=25, Comma=26, Assign=27, DoubleQMark=28, 
		QuestionMark=29, Colon=30, Dot=31, DotQ=32, PlusPlus=33, MinusMinus=34, 
		Plus=35, Minus=36, BitNot=37, Not=38, Multiply=39, Divide=40, Modulus=41, 
		RightShiftArithmetic=42, LeftShiftArithmetic=43, LessThan=44, MoreThan=45, 
		LessThanEquals=46, GreaterThanEquals=47, Equals=48, NotEquals=49, BitAnd=50, 
		BitXOr=51, BitOr=52, And=53, Or=54, MultiplyAssign=55, DivideAssign=56, 
		ModulusAssign=57, PlusAssign=58, MinusAssign=59, LeftShiftArithmeticAssign=60, 
		RightShiftArithmeticAssign=61, BitAndAssign=62, BitXorAssign=63, BitOrAssign=64, 
		NativeReference=65, NativeUse=66, NativeExecution=67, DecimalLiteral=68, 
		HexIntegerLiteral=69, OctalIntegerLiteral=70, Break=71, Do=72, Case=73, 
		Else=74, New=75, Catch=76, Finally=77, Return=78, Continue=79, For=80, 
		Foreach=81, Switch=82, While=83, Function=84, Default=85, If=86, Throw=87, 
		In=88, Try=89, Has=90, Is=91, Identifier=92, StringLiteral=93, NativeCodeLiteral=94, 
		WhiteSpaces=95, MultiLineComment=96, SingleLineComment=97, UnexpectedCharacter=98;
	public const int
		RULE_program = 0, RULE_sourceElements = 1, RULE_sourceElement = 2, RULE_statement = 3, 
		RULE_block = 4, RULE_statementList = 5, RULE_emptyStatement = 6, RULE_expressionStatement = 7, 
		RULE_ifStatement = 8, RULE_iterationStatement = 9, RULE_nativeStatement = 10, 
		RULE_continueStatement = 11, RULE_breakStatement = 12, RULE_returnStatement = 13, 
		RULE_switchStatement = 14, RULE_caseBlock = 15, RULE_caseClauses = 16, 
		RULE_caseClause = 17, RULE_defaultClause = 18, RULE_throwStatement = 19, 
		RULE_tryStatement = 20, RULE_catchProduction = 21, RULE_finallyProduction = 22, 
		RULE_functionDeclaration = 23, RULE_formalParameterList = 24, RULE_functionBody = 25, 
		RULE_arrayLiteral = 26, RULE_elementList = 27, RULE_objectLiteral = 28, 
		RULE_propertyNameAndValueList = 29, RULE_propertyAssignment = 30, RULE_arguments = 31, 
		RULE_typeArguments = 32, RULE_explicitTypeHint = 33, RULE_typedArguments = 34, 
		RULE_typeIdentifier = 35, RULE_argumentList = 36, RULE_expressionSequence = 37, 
		RULE_singleExpression = 38, RULE_assignmentOperator = 39, RULE_literal = 40, 
		RULE_numericLiteral = 41, RULE_identifierName = 42, RULE_reservedWord = 43, 
		RULE_keyword = 44, RULE_eos = 45, RULE_eof = 46, RULE_nullLiteral = 47, 
		RULE_refLiteral = 48, RULE_booleanLiteral = 49, RULE_typeLiteral = 50, 
		RULE_typeLiteralIdentifier = 51;
	public static readonly string[] ruleNames = {
		"program", "sourceElements", "sourceElement", "statement", "block", "statementList", 
		"emptyStatement", "expressionStatement", "ifStatement", "iterationStatement", 
		"nativeStatement", "continueStatement", "breakStatement", "returnStatement", 
		"switchStatement", "caseBlock", "caseClauses", "caseClause", "defaultClause", 
		"throwStatement", "tryStatement", "catchProduction", "finallyProduction", 
		"functionDeclaration", "formalParameterList", "functionBody", "arrayLiteral", 
		"elementList", "objectLiteral", "propertyNameAndValueList", "propertyAssignment", 
		"arguments", "typeArguments", "explicitTypeHint", "typedArguments", "typeIdentifier", 
		"argumentList", "expressionSequence", "singleExpression", "assignmentOperator", 
		"literal", "numericLiteral", "identifierName", "reservedWord", "keyword", 
		"eos", "eof", "nullLiteral", "refLiteral", "booleanLiteral", "typeLiteral", 
		"typeLiteralIdentifier"
	};

	private static readonly string[] _LiteralNames = {
		null, "'`R('", "'`U('", "'`'", "'->'", "'#'", "'?.'", "'`E('", "'as'", 
		"'::'", "'with'", "'`E(#'", "'null'", "'ref'", "'true'", "'false'", "'''", 
		"'@'", null, "'['", "']'", "'('", "')'", "'{'", "'}'", "';'", "','", "'='", 
		"'??'", "'?'", "':'", "'.'", "'.?'", "'++'", "'--'", "'+'", "'-'", "'~'", 
		"'!'", "'*'", "'/'", "'%'", "'>>'", "'<<'", "'<'", "'>'", "'<='", "'>='", 
		"'=='", "'!='", "'&'", "'^'", "'|'", "'&&'", "'||'", "'*='", "'/='", "'%='", 
		"'+='", "'-='", "'<<='", "'>>='", "'&='", "'^='", "'|='", "'`R'", "'`U'", 
		"'`E'", null, null, null, "'break'", "'do'", "'case'", "'else'", "'new'", 
		"'catch'", "'finally'", "'return'", "'continue'", "'for'", "'foreach'", 
		"'switch'", "'while'", "'function'", "'default'", "'if'", "'throw'", "'in'", 
		"'try'", "'has'", "'is'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, "LineTerminator", "OpenBracket", "CloseBracket", 
		"OpenParen", "CloseParen", "OpenBrace", "CloseBrace", "SemiColon", "Comma", 
		"Assign", "DoubleQMark", "QuestionMark", "Colon", "Dot", "DotQ", "PlusPlus", 
		"MinusMinus", "Plus", "Minus", "BitNot", "Not", "Multiply", "Divide", 
		"Modulus", "RightShiftArithmetic", "LeftShiftArithmetic", "LessThan", 
		"MoreThan", "LessThanEquals", "GreaterThanEquals", "Equals", "NotEquals", 
		"BitAnd", "BitXOr", "BitOr", "And", "Or", "MultiplyAssign", "DivideAssign", 
		"ModulusAssign", "PlusAssign", "MinusAssign", "LeftShiftArithmeticAssign", 
		"RightShiftArithmeticAssign", "BitAndAssign", "BitXorAssign", "BitOrAssign", 
		"NativeReference", "NativeUse", "NativeExecution", "DecimalLiteral", "HexIntegerLiteral", 
		"OctalIntegerLiteral", "Break", "Do", "Case", "Else", "New", "Catch", 
		"Finally", "Return", "Continue", "For", "Foreach", "Switch", "While", 
		"Function", "Default", "If", "Throw", "In", "Try", "Has", "Is", "Identifier", 
		"StringLiteral", "NativeCodeLiteral", "WhiteSpaces", "MultiLineComment", 
		"SingleLineComment", "UnexpectedCharacter"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "ITVScripting.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static ITVScriptingParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}


	  
	    ///<summary>Returns <c>true</c> iff on the current index of the parser's
	    ///token stream a token of the given <c>type</c> exists on the
	    ///<c>Hidden</c> channel.</summary>
	    ///<param name="type">the type of the token on the <c>Hidden</c> channel
	    ///to check.</param>
	    ///<returns><c>true</c> iff on the current index of the parser's
	    ///token stream a token of the given <c>type</c> exists on the
	    ///<c>Hidden</c> channel.</returns>
	    private bool here(int type) {

	        // Get the token ahead of the current index.
	        int possibleIndexEosToken = this.CurrentToken.TokenIndex - 1;
	        IToken ahead = TokenStream.Get(possibleIndexEosToken);

	        // Check if the token resides on the Hidden channel and if it's of the
	        // provided type.
	        return (ahead.Channel == Lexer.Hidden) && (ahead.Type == type);
	    }

	    ///<summary>Returns <c>true</c> iff on the current index of the parser's
	    ///token stream a token exists on the <c>Hidden</c> channel which
	    ///either is a line terminator, or is a multi line comment that
	    ///contains a line terminator.</summary>
	    ///<returns><c>true</c> iff on the current index of the parser's
	    ///token stream a token exists on the <c>Hidden</c> channel which
	    ///either is a line terminator, or is a multi line comment that
	    ///contains a line terminator.</returns>
	    private bool lineTerminatorAhead() {

	        // Get the token ahead of the current index.
	        int possibleIndexEosToken = this.CurrentToken.TokenIndex - 1;
	        IToken ahead = TokenStream.Get(possibleIndexEosToken);

	        if (ahead.Channel != Lexer.Hidden) {
	            // We're only interested in tokens on the Hidden channel.
	            return false;
	        }

			if (ahead.Type == LineTerminator) {
	            // There is definitely a line terminator ahead.
	            return true;
	        }

	        while (ahead.Type == WhiteSpaces) {
	            // Get the token ahead of the current whitespaces.
	            possibleIndexEosToken = ahead.TokenIndex - 1;
	            ahead = TokenStream.Get(possibleIndexEosToken);
	        }
	        // Get the token's text and type.
	        string text = ahead.Text;
	        int type = ahead.Type;

	        // Check if the token is, or contains a line terminator.
	        return (type == MultiLineComment && (text.Contains("\r") || text.Contains("\n"))) ||
	                (type == LineTerminator);
	    }                                

		public ITVScriptingParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public ITVScriptingParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ProgramContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(ITVScriptingParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SourceElementsContext sourceElements() {
			return GetRuleContext<SourceElementsContext>(0);
		}
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgram(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(Context, State);
		EnterRule(_localctx, 0, RULE_program);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 105;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,0,Context) ) {
			case 1:
				{
				State = 104;
				sourceElements();
				}
				break;
			}
			State = 107;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SourceElementsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SourceElementContext[] sourceElement() {
			return GetRuleContexts<SourceElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SourceElementContext sourceElement(int i) {
			return GetRuleContext<SourceElementContext>(i);
		}
		public SourceElementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sourceElements; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSourceElements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SourceElementsContext sourceElements() {
		SourceElementsContext _localctx = new SourceElementsContext(Context, State);
		EnterRule(_localctx, 2, RULE_sourceElements);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 110;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 109;
					sourceElement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 112;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,1,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SourceElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionDeclarationContext functionDeclaration() {
			return GetRuleContext<FunctionDeclarationContext>(0);
		}
		public SourceElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sourceElement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSourceElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SourceElementContext sourceElement() {
		SourceElementContext _localctx = new SourceElementContext(Context, State);
		EnterRule(_localctx, 4, RULE_sourceElement);
		try {
			State = 116;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 114;
				statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 115;
				functionDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EmptyStatementContext emptyStatement() {
			return GetRuleContext<EmptyStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionStatementContext expressionStatement() {
			return GetRuleContext<ExpressionStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IterationStatementContext iterationStatement() {
			return GetRuleContext<IterationStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ContinueStatementContext continueStatement() {
			return GetRuleContext<ContinueStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BreakStatementContext breakStatement() {
			return GetRuleContext<BreakStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturnStatementContext returnStatement() {
			return GetRuleContext<ReturnStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SwitchStatementContext switchStatement() {
			return GetRuleContext<SwitchStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ThrowStatementContext throwStatement() {
			return GetRuleContext<ThrowStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TryStatementContext tryStatement() {
			return GetRuleContext<TryStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NativeStatementContext nativeStatement() {
			return GetRuleContext<NativeStatementContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 6, RULE_statement);
		try {
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 118;
				block();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 119;
				emptyStatement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 120;
				expressionStatement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 121;
				ifStatement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 122;
				iterationStatement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 123;
				continueStatement();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 124;
				breakStatement();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 125;
				returnStatement();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 126;
				switchStatement();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 127;
				throwStatement();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 128;
				tryStatement();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 129;
				nativeStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBrace() { return GetToken(ITVScriptingParser.OpenBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBrace() { return GetToken(ITVScriptingParser.CloseBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(Context, State);
		EnterRule(_localctx, 8, RULE_block);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(OpenBrace);
			State = 134;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 133;
				statementList();
				}
				break;
			}
			State = 136;
			Match(CloseBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public StatementListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatementList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementListContext statementList() {
		StatementListContext _localctx = new StatementListContext(Context, State);
		EnterRule(_localctx, 10, RULE_statementList);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 139;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 138;
					statement();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 141;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EmptyStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SemiColon() { return GetToken(ITVScriptingParser.SemiColon, 0); }
		public EmptyStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_emptyStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEmptyStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EmptyStatementContext emptyStatement() {
		EmptyStatementContext _localctx = new EmptyStatementContext(Context, State);
		EnterRule(_localctx, 12, RULE_emptyStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 143;
			Match(SemiColon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionSequenceContext expressionSequence() {
			return GetRuleContext<ExpressionSequenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public ExpressionStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionStatementContext expressionStatement() {
		ExpressionStatementContext _localctx = new ExpressionStatementContext(Context, State);
		EnterRule(_localctx, 14, RULE_expressionStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 145;
			if (!((TokenStream.LA(1) != OpenBrace) && (TokenStream.LA(1) != Function))) throw new FailedPredicateException(this, "(TokenStream.LA(1) != OpenBrace) && (TokenStream.LA(1) != Function)");
			State = 146;
			expressionSequence();
			State = 147;
			eos();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode If() { return GetToken(ITVScriptingParser.If, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(ITVScriptingParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Else() { return GetToken(ITVScriptingParser.Else, 0); }
		public IfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStatementContext ifStatement() {
		IfStatementContext _localctx = new IfStatementContext(Context, State);
		EnterRule(_localctx, 16, RULE_ifStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 149;
			Match(If);
			State = 150;
			Match(OpenParen);
			State = 151;
			singleExpression(0);
			State = 152;
			Match(CloseParen);
			State = 153;
			statement();
			State = 156;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,6,Context) ) {
			case 1:
				{
				State = 154;
				Match(Else);
				State = 155;
				statement();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IterationStatementContext : ParserRuleContext {
		public IterationStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_iterationStatement; } }
	 
		public IterationStatementContext() { }
		public virtual void CopyFrom(IterationStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DoStatementContext : IterationStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Do() { return GetToken(ITVScriptingParser.Do, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode While() { return GetToken(ITVScriptingParser.While, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(ITVScriptingParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public DoStatementContext(IterationStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDoStatement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class WhileStatementContext : IterationStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode While() { return GetToken(ITVScriptingParser.While, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(ITVScriptingParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public WhileStatementContext(IterationStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhileStatement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ForStatementContext : IterationStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode For() { return GetToken(ITVScriptingParser.For, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(ITVScriptingParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SemiColon() { return GetTokens(ITVScriptingParser.SemiColon); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SemiColon(int i) {
			return GetToken(ITVScriptingParser.SemiColon, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionSequenceContext[] expressionSequence() {
			return GetRuleContexts<ExpressionSequenceContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionSequenceContext expressionSequence(int i) {
			return GetRuleContext<ExpressionSequenceContext>(i);
		}
		public ForStatementContext(IterationStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForStatement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ForInStatementContext : IterationStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Foreach() { return GetToken(ITVScriptingParser.Foreach, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(ITVScriptingParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode In() { return GetToken(ITVScriptingParser.In, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement() {
			return GetRuleContext<StatementContext>(0);
		}
		public ForInStatementContext(IterationStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForInStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IterationStatementContext iterationStatement() {
		IterationStatementContext _localctx = new IterationStatementContext(Context, State);
		EnterRule(_localctx, 18, RULE_iterationStatement);
		int _la;
		try {
			State = 195;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Do:
				_localctx = new DoStatementContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 158;
				Match(Do);
				State = 159;
				statement();
				State = 160;
				Match(While);
				State = 161;
				Match(OpenParen);
				State = 162;
				singleExpression(0);
				State = 163;
				Match(CloseParen);
				State = 164;
				eos();
				}
				break;
			case While:
				_localctx = new WhileStatementContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 166;
				Match(While);
				State = 167;
				Match(OpenParen);
				State = 168;
				singleExpression(0);
				State = 169;
				Match(CloseParen);
				State = 170;
				statement();
				}
				break;
			case Foreach:
				_localctx = new ForInStatementContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 172;
				Match(Foreach);
				State = 173;
				Match(OpenParen);
				State = 174;
				singleExpression(0);
				State = 175;
				Match(In);
				State = 176;
				singleExpression(0);
				State = 177;
				Match(CloseParen);
				State = 178;
				statement();
				}
				break;
			case For:
				_localctx = new ForStatementContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 180;
				Match(For);
				State = 181;
				Match(OpenParen);
				State = 183;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__6) | (1L << T__10) | (1L << T__11) | (1L << T__13) | (1L << T__14) | (1L << T__15) | (1L << OpenBracket) | (1L << OpenParen) | (1L << OpenBrace) | (1L << PlusPlus) | (1L << MinusMinus) | (1L << Plus) | (1L << Minus) | (1L << BitNot) | (1L << Not))) != 0) || ((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (DecimalLiteral - 68)) | (1L << (HexIntegerLiteral - 68)) | (1L << (OctalIntegerLiteral - 68)) | (1L << (New - 68)) | (1L << (Function - 68)) | (1L << (Identifier - 68)) | (1L << (StringLiteral - 68)))) != 0)) {
					{
					State = 182;
					expressionSequence();
					}
				}

				State = 185;
				Match(SemiColon);
				State = 187;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__6) | (1L << T__10) | (1L << T__11) | (1L << T__13) | (1L << T__14) | (1L << T__15) | (1L << OpenBracket) | (1L << OpenParen) | (1L << OpenBrace) | (1L << PlusPlus) | (1L << MinusMinus) | (1L << Plus) | (1L << Minus) | (1L << BitNot) | (1L << Not))) != 0) || ((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (DecimalLiteral - 68)) | (1L << (HexIntegerLiteral - 68)) | (1L << (OctalIntegerLiteral - 68)) | (1L << (New - 68)) | (1L << (Function - 68)) | (1L << (Identifier - 68)) | (1L << (StringLiteral - 68)))) != 0)) {
					{
					State = 186;
					expressionSequence();
					}
				}

				State = 189;
				Match(SemiColon);
				State = 191;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__6) | (1L << T__10) | (1L << T__11) | (1L << T__13) | (1L << T__14) | (1L << T__15) | (1L << OpenBracket) | (1L << OpenParen) | (1L << OpenBrace) | (1L << PlusPlus) | (1L << MinusMinus) | (1L << Plus) | (1L << Minus) | (1L << BitNot) | (1L << Not))) != 0) || ((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (DecimalLiteral - 68)) | (1L << (HexIntegerLiteral - 68)) | (1L << (OctalIntegerLiteral - 68)) | (1L << (New - 68)) | (1L << (Function - 68)) | (1L << (Identifier - 68)) | (1L << (StringLiteral - 68)))) != 0)) {
					{
					State = 190;
					expressionSequence();
					}
				}

				State = 193;
				Match(CloseParen);
				State = 194;
				statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NativeStatementContext : ParserRuleContext {
		public NativeStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nativeStatement; } }
	 
		public NativeStatementContext() { }
		public virtual void CopyFrom(NativeStatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class NativeUsingContext : NativeStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(ITVScriptingParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(ITVScriptingParser.StringLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public NativeUsingContext(NativeStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNativeUsing(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NativeReferenceContext : NativeStatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(ITVScriptingParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(ITVScriptingParser.StringLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public NativeReferenceContext(NativeStatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNativeReference(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NativeStatementContext nativeStatement() {
		NativeStatementContext _localctx = new NativeStatementContext(Context, State);
		EnterRule(_localctx, 20, RULE_nativeStatement);
		try {
			State = 207;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case T__0:
				_localctx = new NativeReferenceContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 197;
				Match(T__0);
				State = 198;
				Match(Identifier);
				State = 199;
				Match(CloseParen);
				State = 200;
				Match(StringLiteral);
				State = 201;
				eos();
				}
				break;
			case T__1:
				_localctx = new NativeUsingContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 202;
				Match(T__1);
				State = 203;
				Match(Identifier);
				State = 204;
				Match(CloseParen);
				State = 205;
				Match(StringLiteral);
				State = 206;
				eos();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ContinueStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Continue() { return GetToken(ITVScriptingParser.Continue, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public ContinueStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_continueStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContinueStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ContinueStatementContext continueStatement() {
		ContinueStatementContext _localctx = new ContinueStatementContext(Context, State);
		EnterRule(_localctx, 22, RULE_continueStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 209;
			Match(Continue);
			State = 210;
			eos();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BreakStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Break() { return GetToken(ITVScriptingParser.Break, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public BreakStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_breakStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBreakStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BreakStatementContext breakStatement() {
		BreakStatementContext _localctx = new BreakStatementContext(Context, State);
		EnterRule(_localctx, 24, RULE_breakStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 212;
			Match(Break);
			State = 213;
			eos();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Return() { return GetToken(ITVScriptingParser.Return, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		public ReturnStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturnStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReturnStatementContext returnStatement() {
		ReturnStatementContext _localctx = new ReturnStatementContext(Context, State);
		EnterRule(_localctx, 26, RULE_returnStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 215;
			Match(Return);
			State = 217;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
			case 1:
				{
				State = 216;
				singleExpression(0);
				}
				break;
			}
			State = 219;
			eos();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SwitchStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Switch() { return GetToken(ITVScriptingParser.Switch, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(ITVScriptingParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CaseBlockContext caseBlock() {
			return GetRuleContext<CaseBlockContext>(0);
		}
		public SwitchStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_switchStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSwitchStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SwitchStatementContext switchStatement() {
		SwitchStatementContext _localctx = new SwitchStatementContext(Context, State);
		EnterRule(_localctx, 28, RULE_switchStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 221;
			Match(Switch);
			State = 222;
			Match(OpenParen);
			State = 223;
			singleExpression(0);
			State = 224;
			Match(CloseParen);
			State = 225;
			caseBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseBlockContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBrace() { return GetToken(ITVScriptingParser.OpenBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CaseClausesContext caseClauses() {
			return GetRuleContext<CaseClausesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBrace() { return GetToken(ITVScriptingParser.CloseBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DefaultClauseContext defaultClause() {
			return GetRuleContext<DefaultClauseContext>(0);
		}
		public CaseBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseBlock; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaseBlockContext caseBlock() {
		CaseBlockContext _localctx = new CaseBlockContext(Context, State);
		EnterRule(_localctx, 30, RULE_caseBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 227;
			Match(OpenBrace);
			State = 228;
			caseClauses();
			State = 230;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Default) {
				{
				State = 229;
				defaultClause();
				}
			}

			State = 232;
			Match(CloseBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseClausesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CaseClauseContext[] caseClause() {
			return GetRuleContexts<CaseClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseClauseContext caseClause(int i) {
			return GetRuleContext<CaseClauseContext>(i);
		}
		public CaseClausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseClauses; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseClauses(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaseClausesContext caseClauses() {
		CaseClausesContext _localctx = new CaseClausesContext(Context, State);
		EnterRule(_localctx, 32, RULE_caseClauses);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 235;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 234;
				caseClause();
				}
				}
				State = 237;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==Case );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Case() { return GetToken(ITVScriptingParser.Case, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(ITVScriptingParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		public CaseClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaseClauseContext caseClause() {
		CaseClauseContext _localctx = new CaseClauseContext(Context, State);
		EnterRule(_localctx, 34, RULE_caseClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 239;
			Match(Case);
			State = 240;
			singleExpression(0);
			State = 241;
			Match(Colon);
			State = 243;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				{
				State = 242;
				statementList();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefaultClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Default() { return GetToken(ITVScriptingParser.Default, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(ITVScriptingParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementListContext statementList() {
			return GetRuleContext<StatementListContext>(0);
		}
		public DefaultClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defaultClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefaultClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DefaultClauseContext defaultClause() {
		DefaultClauseContext _localctx = new DefaultClauseContext(Context, State);
		EnterRule(_localctx, 36, RULE_defaultClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 245;
			Match(Default);
			State = 246;
			Match(Colon);
			State = 248;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 247;
				statementList();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ThrowStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Throw() { return GetToken(ITVScriptingParser.Throw, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		public ThrowStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_throwStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitThrowStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ThrowStatementContext throwStatement() {
		ThrowStatementContext _localctx = new ThrowStatementContext(Context, State);
		EnterRule(_localctx, 38, RULE_throwStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			Match(Throw);
			State = 252;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				{
				State = 251;
				singleExpression(0);
				}
				break;
			}
			State = 254;
			eos();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TryStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Try() { return GetToken(ITVScriptingParser.Try, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CatchProductionContext catchProduction() {
			return GetRuleContext<CatchProductionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FinallyProductionContext finallyProduction() {
			return GetRuleContext<FinallyProductionContext>(0);
		}
		public TryStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tryStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTryStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TryStatementContext tryStatement() {
		TryStatementContext _localctx = new TryStatementContext(Context, State);
		EnterRule(_localctx, 40, RULE_tryStatement);
		try {
			State = 269;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,18,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 256;
				Match(Try);
				State = 257;
				block();
				State = 258;
				catchProduction();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 260;
				Match(Try);
				State = 261;
				block();
				State = 262;
				finallyProduction();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 264;
				Match(Try);
				State = 265;
				block();
				State = 266;
				catchProduction();
				State = 267;
				finallyProduction();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CatchProductionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Catch() { return GetToken(ITVScriptingParser.Catch, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(ITVScriptingParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(ITVScriptingParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public CatchProductionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_catchProduction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCatchProduction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CatchProductionContext catchProduction() {
		CatchProductionContext _localctx = new CatchProductionContext(Context, State);
		EnterRule(_localctx, 42, RULE_catchProduction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 271;
			Match(Catch);
			State = 272;
			Match(OpenParen);
			State = 273;
			Match(Identifier);
			State = 274;
			Match(CloseParen);
			State = 275;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FinallyProductionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Finally() { return GetToken(ITVScriptingParser.Finally, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public FinallyProductionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_finallyProduction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFinallyProduction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FinallyProductionContext finallyProduction() {
		FinallyProductionContext _localctx = new FinallyProductionContext(Context, State);
		EnterRule(_localctx, 44, RULE_finallyProduction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 277;
			Match(Finally);
			State = 278;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionDeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Function() { return GetToken(ITVScriptingParser.Function, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(ITVScriptingParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(ITVScriptingParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBrace() { return GetToken(ITVScriptingParser.OpenBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionBodyContext functionBody() {
			return GetRuleContext<FunctionBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBrace() { return GetToken(ITVScriptingParser.CloseBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FormalParameterListContext formalParameterList() {
			return GetRuleContext<FormalParameterListContext>(0);
		}
		public FunctionDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionDeclaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionDeclarationContext functionDeclaration() {
		FunctionDeclarationContext _localctx = new FunctionDeclarationContext(Context, State);
		EnterRule(_localctx, 46, RULE_functionDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 280;
			Match(Function);
			State = 281;
			Match(Identifier);
			State = 282;
			Match(OpenParen);
			State = 284;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 283;
				formalParameterList();
				}
			}

			State = 286;
			Match(CloseParen);
			State = 287;
			Match(OpenBrace);
			State = 288;
			functionBody();
			State = 289;
			Match(CloseBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FormalParameterListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(ITVScriptingParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(ITVScriptingParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(ITVScriptingParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(ITVScriptingParser.Comma, i);
		}
		public FormalParameterListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_formalParameterList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFormalParameterList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FormalParameterListContext formalParameterList() {
		FormalParameterListContext _localctx = new FormalParameterListContext(Context, State);
		EnterRule(_localctx, 48, RULE_formalParameterList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 291;
			Match(Identifier);
			State = 296;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 292;
				Match(Comma);
				State = 293;
				Match(Identifier);
				}
				}
				State = 298;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SourceElementsContext sourceElements() {
			return GetRuleContext<SourceElementsContext>(0);
		}
		public FunctionBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionBodyContext functionBody() {
		FunctionBodyContext _localctx = new FunctionBodyContext(Context, State);
		EnterRule(_localctx, 50, RULE_functionBody);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 300;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,21,Context) ) {
			case 1:
				{
				State = 299;
				sourceElements();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBracket() { return GetToken(ITVScriptingParser.OpenBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBracket() { return GetToken(ITVScriptingParser.CloseBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ElementListContext elementList() {
			return GetRuleContext<ElementListContext>(0);
		}
		public ArrayLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrayLiteralContext arrayLiteral() {
		ArrayLiteralContext _localctx = new ArrayLiteralContext(Context, State);
		EnterRule(_localctx, 52, RULE_arrayLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 302;
			Match(OpenBracket);
			State = 304;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__6) | (1L << T__10) | (1L << T__11) | (1L << T__13) | (1L << T__14) | (1L << T__15) | (1L << OpenBracket) | (1L << OpenParen) | (1L << OpenBrace) | (1L << PlusPlus) | (1L << MinusMinus) | (1L << Plus) | (1L << Minus) | (1L << BitNot) | (1L << Not))) != 0) || ((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (DecimalLiteral - 68)) | (1L << (HexIntegerLiteral - 68)) | (1L << (OctalIntegerLiteral - 68)) | (1L << (New - 68)) | (1L << (Function - 68)) | (1L << (Identifier - 68)) | (1L << (StringLiteral - 68)))) != 0)) {
				{
				State = 303;
				elementList();
				}
			}

			State = 306;
			Match(CloseBracket);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(ITVScriptingParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(ITVScriptingParser.Comma, i);
		}
		public ElementListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementListContext elementList() {
		ElementListContext _localctx = new ElementListContext(Context, State);
		EnterRule(_localctx, 54, RULE_elementList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 308;
			singleExpression(0);
			State = 313;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 309;
				Match(Comma);
				State = 310;
				singleExpression(0);
				}
				}
				State = 315;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBrace() { return GetToken(ITVScriptingParser.OpenBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBrace() { return GetToken(ITVScriptingParser.CloseBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropertyNameAndValueListContext propertyNameAndValueList() {
			return GetRuleContext<PropertyNameAndValueListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(ITVScriptingParser.Comma, 0); }
		public ObjectLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectLiteralContext objectLiteral() {
		ObjectLiteralContext _localctx = new ObjectLiteralContext(Context, State);
		EnterRule(_localctx, 56, RULE_objectLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 316;
			Match(OpenBrace);
			State = 318;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__11) | (1L << T__13) | (1L << T__14) | (1L << T__15))) != 0) || ((((_la - 71)) & ~0x3f) == 0 && ((1L << (_la - 71)) & ((1L << (Break - 71)) | (1L << (Do - 71)) | (1L << (Case - 71)) | (1L << (Else - 71)) | (1L << (New - 71)) | (1L << (Catch - 71)) | (1L << (Finally - 71)) | (1L << (Return - 71)) | (1L << (Continue - 71)) | (1L << (For - 71)) | (1L << (Switch - 71)) | (1L << (While - 71)) | (1L << (Function - 71)) | (1L << (Default - 71)) | (1L << (If - 71)) | (1L << (Throw - 71)) | (1L << (In - 71)) | (1L << (Try - 71)) | (1L << (Has - 71)) | (1L << (Is - 71)) | (1L << (Identifier - 71)))) != 0)) {
				{
				State = 317;
				propertyNameAndValueList();
				}
			}

			State = 321;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Comma) {
				{
				State = 320;
				Match(Comma);
				}
			}

			State = 323;
			Match(CloseBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyNameAndValueListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PropertyAssignmentContext[] propertyAssignment() {
			return GetRuleContexts<PropertyAssignmentContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropertyAssignmentContext propertyAssignment(int i) {
			return GetRuleContext<PropertyAssignmentContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(ITVScriptingParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(ITVScriptingParser.Comma, i);
		}
		public PropertyNameAndValueListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyNameAndValueList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyNameAndValueList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyNameAndValueListContext propertyNameAndValueList() {
		PropertyNameAndValueListContext _localctx = new PropertyNameAndValueListContext(Context, State);
		EnterRule(_localctx, 58, RULE_propertyNameAndValueList);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 325;
			propertyAssignment();
			State = 333;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,27,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 328;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case Comma:
						{
						State = 326;
						Match(Comma);
						}
						break;
					case T__11:
					case T__13:
					case T__14:
					case T__15:
					case Break:
					case Do:
					case Case:
					case Else:
					case New:
					case Catch:
					case Finally:
					case Return:
					case Continue:
					case For:
					case Switch:
					case While:
					case Function:
					case Default:
					case If:
					case Throw:
					case In:
					case Try:
					case Has:
					case Is:
					case Identifier:
						{
						NotifyErrorListeners("Missing ','!");
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 330;
					propertyAssignment();
					}
					} 
				}
				State = 335;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,27,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyAssignmentContext : ParserRuleContext {
		public PropertyAssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyAssignment; } }
	 
		public PropertyAssignmentContext() { }
		public virtual void CopyFrom(PropertyAssignmentContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PropertyExpressionAssignmentContext : PropertyAssignmentContext {
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierNameContext identifierName() {
			return GetRuleContext<IdentifierNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(ITVScriptingParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(ITVScriptingParser.Assign, 0); }
		public PropertyExpressionAssignmentContext(PropertyAssignmentContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyExpressionAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyAssignmentContext propertyAssignment() {
		PropertyAssignmentContext _localctx = new PropertyAssignmentContext(Context, State);
		EnterRule(_localctx, 60, RULE_propertyAssignment);
		try {
			_localctx = new PropertyExpressionAssignmentContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 336;
			identifierName();
			State = 340;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Colon:
				{
				State = 337;
				Match(Colon);
				}
				break;
			case Assign:
				{
				State = 338;
				Match(Assign);
				NotifyErrorListeners("':' expected!");
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 342;
			singleExpression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(ITVScriptingParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public ArgumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arguments; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArguments(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentsContext arguments() {
		ArgumentsContext _localctx = new ArgumentsContext(Context, State);
		EnterRule(_localctx, 62, RULE_arguments);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 344;
			Match(OpenParen);
			State = 346;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__6) | (1L << T__10) | (1L << T__11) | (1L << T__13) | (1L << T__14) | (1L << T__15) | (1L << OpenBracket) | (1L << OpenParen) | (1L << OpenBrace) | (1L << PlusPlus) | (1L << MinusMinus) | (1L << Plus) | (1L << Minus) | (1L << BitNot) | (1L << Not))) != 0) || ((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (DecimalLiteral - 68)) | (1L << (HexIntegerLiteral - 68)) | (1L << (OctalIntegerLiteral - 68)) | (1L << (New - 68)) | (1L << (Function - 68)) | (1L << (Identifier - 68)) | (1L << (StringLiteral - 68)))) != 0)) {
				{
				State = 345;
				argumentList();
				}
			}

			State = 348;
			Match(CloseParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeArgumentsContext : ParserRuleContext {
		public TypeArgumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeArguments; } }
	 
		public TypeArgumentsContext() { }
		public virtual void CopyFrom(TypeArgumentsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class OpenGenericsContext : TypeArgumentsContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] DecimalLiteral() { return GetTokens(ITVScriptingParser.DecimalLiteral); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DecimalLiteral(int i) {
			return GetToken(ITVScriptingParser.DecimalLiteral, i);
		}
		public OpenGenericsContext(TypeArgumentsContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpenGenerics(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FinalGenericsContext : TypeArgumentsContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LessThan() { return GetToken(ITVScriptingParser.LessThan, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypedArgumentsContext typedArguments() {
			return GetRuleContext<TypedArgumentsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MoreThan() { return GetToken(ITVScriptingParser.MoreThan, 0); }
		public FinalGenericsContext(TypeArgumentsContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFinalGenerics(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeArgumentsContext typeArguments() {
		TypeArgumentsContext _localctx = new TypeArgumentsContext(Context, State);
		EnterRule(_localctx, 64, RULE_typeArguments);
		try {
			int _alt;
			State = 360;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LessThan:
				_localctx = new FinalGenericsContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 350;
				Match(LessThan);
				State = 351;
				typedArguments();
				State = 352;
				Match(MoreThan);
				}
				break;
			case T__2:
				_localctx = new OpenGenericsContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 356;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 354;
						Match(T__2);
						State = 355;
						Match(DecimalLiteral);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 358;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,30,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExplicitTypeHintContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeIdentifierContext typeIdentifier() {
			return GetRuleContext<TypeIdentifierContext>(0);
		}
		public ExplicitTypeHintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_explicitTypeHint; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExplicitTypeHint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExplicitTypeHintContext explicitTypeHint() {
		ExplicitTypeHintContext _localctx = new ExplicitTypeHintContext(Context, State);
		EnterRule(_localctx, 66, RULE_explicitTypeHint);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 362;
			Match(T__3);
			State = 363;
			typeIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedArgumentsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeIdentifierContext[] typeIdentifier() {
			return GetRuleContexts<TypeIdentifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeIdentifierContext typeIdentifier(int i) {
			return GetRuleContext<TypeIdentifierContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(ITVScriptingParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(ITVScriptingParser.Comma, i);
		}
		public TypedArgumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typedArguments; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypedArguments(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypedArgumentsContext typedArguments() {
		TypedArgumentsContext _localctx = new TypedArgumentsContext(Context, State);
		EnterRule(_localctx, 68, RULE_typedArguments);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 365;
			typeIdentifier();
			State = 370;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 366;
				Match(Comma);
				State = 367;
				typeIdentifier();
				}
				}
				State = 372;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(ITVScriptingParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(ITVScriptingParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Dot() { return GetTokens(ITVScriptingParser.Dot); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot(int i) {
			return GetToken(ITVScriptingParser.Dot, i);
		}
		public TypeIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeIdentifierContext typeIdentifier() {
		TypeIdentifierContext _localctx = new TypeIdentifierContext(Context, State);
		EnterRule(_localctx, 70, RULE_typeIdentifier);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 373;
			Match(T__4);
			State = 374;
			Match(Identifier);
			State = 379;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,33,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 375;
					Match(Dot);
					State = 376;
					Match(Identifier);
					}
					} 
				}
				State = 381;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,33,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(ITVScriptingParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(ITVScriptingParser.Comma, i);
		}
		public ArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentListContext argumentList() {
		ArgumentListContext _localctx = new ArgumentListContext(Context, State);
		EnterRule(_localctx, 72, RULE_argumentList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 382;
			singleExpression(0);
			State = 387;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 383;
				Match(Comma);
				State = 384;
				singleExpression(0);
				}
				}
				State = 389;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionSequenceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(ITVScriptingParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(ITVScriptingParser.Comma, i);
		}
		public ExpressionSequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionSequence; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionSequence(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionSequenceContext expressionSequence() {
		ExpressionSequenceContext _localctx = new ExpressionSequenceContext(Context, State);
		EnterRule(_localctx, 74, RULE_expressionSequence);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 390;
			singleExpression(0);
			State = 395;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,35,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 391;
					Match(Comma);
					State = 392;
					singleExpression(0);
					}
					} 
				}
				State = 397;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,35,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SingleExpressionContext : ParserRuleContext {
		public SingleExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_singleExpression; } }
	 
		public SingleExpressionContext() { }
		public virtual void CopyFrom(SingleExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TernaryExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QuestionMark() { return GetToken(ITVScriptingParser.QuestionMark, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(ITVScriptingParser.Colon, 0); }
		public TernaryExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTernaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalAndExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode And() { return GetToken(ITVScriptingParser.And, 0); }
		public LogicalAndExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalAndExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PreIncrementExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PlusPlus() { return GetToken(ITVScriptingParser.PlusPlus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		public PreIncrementExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreIncrementExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ObjectLiteralExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ObjectLiteralContext objectLiteral() {
			return GetRuleContext<ObjectLiteralContext>(0);
		}
		public ObjectLiteralExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectLiteralExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalOrExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Or() { return GetToken(ITVScriptingParser.Or, 0); }
		public LogicalOrExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NotExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Not() { return GetToken(ITVScriptingParser.Not, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		public NotExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNotExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PreDecreaseExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MinusMinus() { return GetToken(ITVScriptingParser.MinusMinus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		public PreDecreaseExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreDecreaseExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ArgumentsExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentsContext arguments() {
			return GetRuleContext<ArgumentsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeArgumentsContext typeArguments() {
			return GetRuleContext<TypeArgumentsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExplicitTypeHintContext explicitTypeHint() {
			return GetRuleContext<ExplicitTypeHintContext>(0);
		}
		public ArgumentsExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentsExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FunctionExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Function() { return GetToken(ITVScriptingParser.Function, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(ITVScriptingParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBrace() { return GetToken(ITVScriptingParser.OpenBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionBodyContext functionBody() {
			return GetRuleContext<FunctionBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBrace() { return GetToken(ITVScriptingParser.CloseBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(ITVScriptingParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FormalParameterListContext formalParameterList() {
			return GetRuleContext<FormalParameterListContext>(0);
		}
		public FunctionExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NativeExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(ITVScriptingParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(ITVScriptingParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		public NativeExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNativeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnaryMinusExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Minus() { return GetToken(ITVScriptingParser.Minus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		public UnaryMinusExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryMinusExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AssignmentExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Assign() { return GetToken(ITVScriptingParser.Assign, 0); }
		public AssignmentExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignmentExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberDotQExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierNameContext identifierName() {
			return GetRuleContext<IdentifierNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExplicitTypeHintContext explicitTypeHint() {
			return GetRuleContext<ExplicitTypeHintContext>(0);
		}
		public MemberDotQExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberDotQExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PostDecreaseExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MinusMinus() { return GetToken(ITVScriptingParser.MinusMinus, 0); }
		public PostDecreaseExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostDecreaseExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnaryPlusExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(ITVScriptingParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		public UnaryPlusExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryPlusExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class EqualityExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equals() { return GetToken(ITVScriptingParser.Equals, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NotEquals() { return GetToken(ITVScriptingParser.NotEquals, 0); }
		public EqualityExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEqualityExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BitXOrExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BitXOr() { return GetToken(ITVScriptingParser.BitXOr, 0); }
		public BitXOrExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitXOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultiplicativeExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Multiply() { return GetToken(ITVScriptingParser.Multiply, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Divide() { return GetToken(ITVScriptingParser.Divide, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Modulus() { return GetToken(ITVScriptingParser.Modulus, 0); }
		public MultiplicativeExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicativeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NativeLiteralExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(ITVScriptingParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NativeCodeLiteral() { return GetToken(ITVScriptingParser.NativeCodeLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		public NativeLiteralExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNativeLiteralExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BitShiftExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftShiftArithmetic() { return GetToken(ITVScriptingParser.LeftShiftArithmetic, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightShiftArithmetic() { return GetToken(ITVScriptingParser.RightShiftArithmetic, 0); }
		public BitShiftExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitShiftExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesizedExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(ITVScriptingParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(ITVScriptingParser.CloseParen, 0); }
		public ParenthesizedExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AdditiveExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(ITVScriptingParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Minus() { return GetToken(ITVScriptingParser.Minus, 0); }
		public AdditiveExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditiveExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RelationalExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LessThan() { return GetToken(ITVScriptingParser.LessThan, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MoreThan() { return GetToken(ITVScriptingParser.MoreThan, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LessThanEquals() { return GetToken(ITVScriptingParser.LessThanEquals, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GreaterThanEquals() { return GetToken(ITVScriptingParser.GreaterThanEquals, 0); }
		public RelationalExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelationalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PostIncrementExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PlusPlus() { return GetToken(ITVScriptingParser.PlusPlus, 0); }
		public PostIncrementExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPostIncrementExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BitNotExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BitNot() { return GetToken(ITVScriptingParser.BitNot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		public BitNotExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitNotExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NewExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode New() { return GetToken(ITVScriptingParser.New, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentsContext arguments() {
			return GetRuleContext<ArgumentsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeArgumentsContext typeArguments() {
			return GetRuleContext<TypeArgumentsContext>(0);
		}
		public NewExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNewExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LiteralExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public LiteralExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ArrayLiteralExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArrayLiteralContext arrayLiteral() {
			return GetRuleContext<ArrayLiteralContext>(0);
		}
		public ArrayLiteralExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayLiteralExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberDotExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(ITVScriptingParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierNameContext identifierName() {
			return GetRuleContext<IdentifierNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExplicitTypeHintContext explicitTypeHint() {
			return GetRuleContext<ExplicitTypeHintContext>(0);
		}
		public MemberDotExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberDotExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class HasMemberExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Has() { return GetToken(ITVScriptingParser.Has, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierNameContext identifierName() {
			return GetRuleContext<IdentifierNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeArgumentsContext typeArguments() {
			return GetRuleContext<TypeArgumentsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentsContext arguments() {
			return GetRuleContext<ArgumentsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExplicitTypeHintContext explicitTypeHint() {
			return GetRuleContext<ExplicitTypeHintContext>(0);
		}
		public HasMemberExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHasMemberExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberIndexExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression() {
			return GetRuleContext<SingleExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBracket() { return GetToken(ITVScriptingParser.OpenBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionSequenceContext expressionSequence() {
			return GetRuleContext<ExpressionSequenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBracket() { return GetToken(ITVScriptingParser.CloseBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExplicitTypeHintContext explicitTypeHint() {
			return GetRuleContext<ExplicitTypeHintContext>(0);
		}
		public MemberIndexExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberIndexExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class InstanceIsNullExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleQMark() { return GetToken(ITVScriptingParser.DoubleQMark, 0); }
		public InstanceIsNullExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInstanceIsNullExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IdentifierExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(ITVScriptingParser.Identifier, 0); }
		public IdentifierExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifierExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BitAndExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BitAnd() { return GetToken(ITVScriptingParser.BitAnd, 0); }
		public BitAndExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitAndExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberIsExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Is() { return GetToken(ITVScriptingParser.Is, 0); }
		public MemberIsExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberIsExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BitOrExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BitOr() { return GetToken(ITVScriptingParser.BitOr, 0); }
		public BitOrExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AssignmentOperatorExpressionContext : SingleExpressionContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext[] singleExpression() {
			return GetRuleContexts<SingleExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleExpressionContext singleExpression(int i) {
			return GetRuleContext<SingleExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentOperatorContext assignmentOperator() {
			return GetRuleContext<AssignmentOperatorContext>(0);
		}
		public AssignmentOperatorExpressionContext(SingleExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignmentOperatorExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SingleExpressionContext singleExpression() {
		return singleExpression(0);
	}

	private SingleExpressionContext singleExpression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		SingleExpressionContext _localctx = new SingleExpressionContext(Context, _parentState);
		SingleExpressionContext _prevctx = _localctx;
		int _startState = 76;
		EnterRecursionRule(_localctx, 76, RULE_singleExpression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 458;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Function:
				{
				_localctx = new FunctionExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 399;
				Match(Function);
				State = 401;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Identifier) {
					{
					State = 400;
					Match(Identifier);
					}
				}

				State = 403;
				Match(OpenParen);
				State = 405;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Identifier) {
					{
					State = 404;
					formalParameterList();
					}
				}

				State = 407;
				Match(CloseParen);
				State = 408;
				Match(OpenBrace);
				State = 409;
				functionBody();
				State = 410;
				Match(CloseBrace);
				}
				break;
			case New:
				{
				_localctx = new NewExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 412;
				Match(New);
				State = 413;
				singleExpression(0);
				State = 415;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==T__2 || _la==LessThan) {
					{
					State = 414;
					typeArguments();
					}
				}

				State = 417;
				arguments();
				}
				break;
			case PlusPlus:
				{
				_localctx = new PreIncrementExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 419;
				Match(PlusPlus);
				State = 420;
				singleExpression(27);
				}
				break;
			case MinusMinus:
				{
				_localctx = new PreDecreaseExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 421;
				Match(MinusMinus);
				State = 422;
				singleExpression(26);
				}
				break;
			case Plus:
				{
				_localctx = new UnaryPlusExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 423;
				Match(Plus);
				State = 424;
				singleExpression(25);
				}
				break;
			case Minus:
				{
				_localctx = new UnaryMinusExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 425;
				Match(Minus);
				State = 426;
				singleExpression(24);
				}
				break;
			case BitNot:
				{
				_localctx = new BitNotExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 427;
				Match(BitNot);
				State = 428;
				singleExpression(23);
				}
				break;
			case Not:
				{
				_localctx = new NotExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 429;
				Match(Not);
				State = 430;
				singleExpression(22);
				}
				break;
			case Identifier:
				{
				_localctx = new IdentifierExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 431;
				Match(Identifier);
				}
				break;
			case T__11:
			case T__13:
			case T__14:
			case T__15:
			case DecimalLiteral:
			case HexIntegerLiteral:
			case OctalIntegerLiteral:
			case StringLiteral:
				{
				_localctx = new LiteralExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 432;
				literal();
				}
				break;
			case OpenBracket:
				{
				_localctx = new ArrayLiteralExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 433;
				arrayLiteral();
				}
				break;
			case OpenBrace:
				{
				_localctx = new ObjectLiteralExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 434;
				objectLiteral();
				}
				break;
			case OpenParen:
				{
				_localctx = new ParenthesizedExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 435;
				Match(OpenParen);
				State = 436;
				singleExpression(0);
				State = 437;
				Match(CloseParen);
				}
				break;
			case T__6:
				{
				_localctx = new NativeExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 439;
				Match(T__6);
				State = 440;
				singleExpression(0);
				State = 441;
				Match(T__7);
				State = 442;
				Match(Identifier);
				State = 443;
				Match(T__3);
				State = 444;
				Match(Identifier);
				State = 445;
				Match(CloseParen);
				State = 446;
				Match(T__8);
				State = 447;
				singleExpression(0);
				State = 448;
				Match(T__9);
				State = 449;
				singleExpression(2);
				}
				break;
			case T__10:
				{
				_localctx = new NativeLiteralExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 451;
				Match(T__10);
				State = 452;
				Match(Identifier);
				State = 453;
				Match(CloseParen);
				State = 454;
				Match(T__8);
				State = 455;
				Match(NativeCodeLiteral);
				State = 456;
				Match(T__9);
				State = 457;
				singleExpression(1);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 556;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,49,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 554;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,48,Context) ) {
					case 1:
						{
						_localctx = new MemberIsExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 460;
						if (!(Precpred(Context, 32))) throw new FailedPredicateException(this, "Precpred(Context, 32)");
						State = 461;
						Match(Is);
						State = 462;
						singleExpression(33);
						}
						break;
					case 2:
						{
						_localctx = new MultiplicativeExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 463;
						if (!(Precpred(Context, 21))) throw new FailedPredicateException(this, "Precpred(Context, 21)");
						State = 464;
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << Multiply) | (1L << Divide) | (1L << Modulus))) != 0)) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 465;
						singleExpression(22);
						}
						break;
					case 3:
						{
						_localctx = new AdditiveExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 466;
						if (!(Precpred(Context, 20))) throw new FailedPredicateException(this, "Precpred(Context, 20)");
						State = 467;
						_la = TokenStream.LA(1);
						if ( !(_la==Plus || _la==Minus) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 468;
						singleExpression(21);
						}
						break;
					case 4:
						{
						_localctx = new BitShiftExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 469;
						if (!(Precpred(Context, 19))) throw new FailedPredicateException(this, "Precpred(Context, 19)");
						State = 470;
						_la = TokenStream.LA(1);
						if ( !(_la==RightShiftArithmetic || _la==LeftShiftArithmetic) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 471;
						singleExpression(20);
						}
						break;
					case 5:
						{
						_localctx = new RelationalExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 472;
						if (!(Precpred(Context, 18))) throw new FailedPredicateException(this, "Precpred(Context, 18)");
						State = 473;
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LessThan) | (1L << MoreThan) | (1L << LessThanEquals) | (1L << GreaterThanEquals))) != 0)) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 474;
						singleExpression(19);
						}
						break;
					case 6:
						{
						_localctx = new EqualityExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 475;
						if (!(Precpred(Context, 17))) throw new FailedPredicateException(this, "Precpred(Context, 17)");
						State = 476;
						_la = TokenStream.LA(1);
						if ( !(_la==Equals || _la==NotEquals) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 477;
						singleExpression(18);
						}
						break;
					case 7:
						{
						_localctx = new BitAndExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 478;
						if (!(Precpred(Context, 16))) throw new FailedPredicateException(this, "Precpred(Context, 16)");
						State = 479;
						Match(BitAnd);
						State = 480;
						singleExpression(17);
						}
						break;
					case 8:
						{
						_localctx = new BitXOrExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 481;
						if (!(Precpred(Context, 15))) throw new FailedPredicateException(this, "Precpred(Context, 15)");
						State = 482;
						Match(BitXOr);
						State = 483;
						singleExpression(16);
						}
						break;
					case 9:
						{
						_localctx = new BitOrExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 484;
						if (!(Precpred(Context, 14))) throw new FailedPredicateException(this, "Precpred(Context, 14)");
						State = 485;
						Match(BitOr);
						State = 486;
						singleExpression(15);
						}
						break;
					case 10:
						{
						_localctx = new LogicalAndExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 487;
						if (!(Precpred(Context, 13))) throw new FailedPredicateException(this, "Precpred(Context, 13)");
						State = 488;
						Match(And);
						State = 489;
						singleExpression(14);
						}
						break;
					case 11:
						{
						_localctx = new LogicalOrExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 490;
						if (!(Precpred(Context, 12))) throw new FailedPredicateException(this, "Precpred(Context, 12)");
						State = 491;
						Match(Or);
						State = 492;
						singleExpression(13);
						}
						break;
					case 12:
						{
						_localctx = new InstanceIsNullExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 493;
						if (!(Precpred(Context, 11))) throw new FailedPredicateException(this, "Precpred(Context, 11)");
						State = 494;
						Match(DoubleQMark);
						State = 495;
						singleExpression(12);
						}
						break;
					case 13:
						{
						_localctx = new TernaryExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 496;
						if (!(Precpred(Context, 10))) throw new FailedPredicateException(this, "Precpred(Context, 10)");
						State = 497;
						Match(QuestionMark);
						State = 498;
						singleExpression(0);
						State = 499;
						Match(Colon);
						State = 500;
						singleExpression(11);
						}
						break;
					case 14:
						{
						_localctx = new AssignmentExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 502;
						if (!(Precpred(Context, 9))) throw new FailedPredicateException(this, "Precpred(Context, 9)");
						State = 503;
						Match(Assign);
						State = 504;
						singleExpression(10);
						}
						break;
					case 15:
						{
						_localctx = new AssignmentOperatorExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 505;
						if (!(Precpred(Context, 8))) throw new FailedPredicateException(this, "Precpred(Context, 8)");
						State = 506;
						assignmentOperator();
						State = 507;
						singleExpression(9);
						}
						break;
					case 16:
						{
						_localctx = new MemberIndexExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 509;
						if (!(Precpred(Context, 36))) throw new FailedPredicateException(this, "Precpred(Context, 36)");
						State = 510;
						Match(OpenBracket);
						State = 511;
						expressionSequence();
						State = 512;
						Match(CloseBracket);
						State = 514;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,40,Context) ) {
						case 1:
							{
							State = 513;
							explicitTypeHint();
							}
							break;
						}
						}
						break;
					case 17:
						{
						_localctx = new MemberDotQExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 516;
						if (!(Precpred(Context, 35))) throw new FailedPredicateException(this, "Precpred(Context, 35)");
						State = 517;
						Match(T__5);
						State = 518;
						identifierName();
						State = 520;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,41,Context) ) {
						case 1:
							{
							State = 519;
							explicitTypeHint();
							}
							break;
						}
						}
						break;
					case 18:
						{
						_localctx = new MemberDotExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 522;
						if (!(Precpred(Context, 34))) throw new FailedPredicateException(this, "Precpred(Context, 34)");
						State = 523;
						Match(Dot);
						State = 524;
						identifierName();
						State = 526;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,42,Context) ) {
						case 1:
							{
							State = 525;
							explicitTypeHint();
							}
							break;
						}
						}
						break;
					case 19:
						{
						_localctx = new HasMemberExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 528;
						if (!(Precpred(Context, 33))) throw new FailedPredicateException(this, "Precpred(Context, 33)");
						State = 529;
						Match(Has);
						State = 530;
						identifierName();
						State = 532;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,43,Context) ) {
						case 1:
							{
							State = 531;
							typeArguments();
							}
							break;
						}
						State = 535;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,44,Context) ) {
						case 1:
							{
							State = 534;
							arguments();
							}
							break;
						}
						State = 538;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,45,Context) ) {
						case 1:
							{
							State = 537;
							explicitTypeHint();
							}
							break;
						}
						}
						break;
					case 20:
						{
						_localctx = new ArgumentsExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 540;
						if (!(Precpred(Context, 31))) throw new FailedPredicateException(this, "Precpred(Context, 31)");
						State = 542;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==T__2 || _la==LessThan) {
							{
							State = 541;
							typeArguments();
							}
						}

						State = 544;
						arguments();
						State = 546;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,47,Context) ) {
						case 1:
							{
							State = 545;
							explicitTypeHint();
							}
							break;
						}
						}
						break;
					case 21:
						{
						_localctx = new PostIncrementExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 548;
						if (!(Precpred(Context, 29))) throw new FailedPredicateException(this, "Precpred(Context, 29)");
						State = 549;
						if (!(!here(LineTerminator))) throw new FailedPredicateException(this, "!here(LineTerminator)");
						State = 550;
						Match(PlusPlus);
						}
						break;
					case 22:
						{
						_localctx = new PostDecreaseExpressionContext(new SingleExpressionContext(_parentctx, _parentState));
						PushNewRecursionContext(_localctx, _startState, RULE_singleExpression);
						State = 551;
						if (!(Precpred(Context, 28))) throw new FailedPredicateException(this, "Precpred(Context, 28)");
						State = 552;
						if (!(!here(LineTerminator))) throw new FailedPredicateException(this, "!here(LineTerminator)");
						State = 553;
						Match(MinusMinus);
						}
						break;
					}
					} 
				}
				State = 558;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,49,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class AssignmentOperatorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MultiplyAssign() { return GetToken(ITVScriptingParser.MultiplyAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DivideAssign() { return GetToken(ITVScriptingParser.DivideAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ModulusAssign() { return GetToken(ITVScriptingParser.ModulusAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PlusAssign() { return GetToken(ITVScriptingParser.PlusAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MinusAssign() { return GetToken(ITVScriptingParser.MinusAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LeftShiftArithmeticAssign() { return GetToken(ITVScriptingParser.LeftShiftArithmeticAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RightShiftArithmeticAssign() { return GetToken(ITVScriptingParser.RightShiftArithmeticAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BitAndAssign() { return GetToken(ITVScriptingParser.BitAndAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BitXorAssign() { return GetToken(ITVScriptingParser.BitXorAssign, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BitOrAssign() { return GetToken(ITVScriptingParser.BitOrAssign, 0); }
		public AssignmentOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignmentOperator; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignmentOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentOperatorContext assignmentOperator() {
		AssignmentOperatorContext _localctx = new AssignmentOperatorContext(Context, State);
		EnterRule(_localctx, 78, RULE_assignmentOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 559;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 55)) & ~0x3f) == 0 && ((1L << (_la - 55)) & ((1L << (MultiplyAssign - 55)) | (1L << (DivideAssign - 55)) | (1L << (ModulusAssign - 55)) | (1L << (PlusAssign - 55)) | (1L << (MinusAssign - 55)) | (1L << (LeftShiftArithmeticAssign - 55)) | (1L << (RightShiftArithmeticAssign - 55)) | (1L << (BitAndAssign - 55)) | (1L << (BitXorAssign - 55)) | (1L << (BitOrAssign - 55)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NullLiteralContext nullLiteral() {
			return GetRuleContext<NullLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BooleanLiteralContext booleanLiteral() {
			return GetRuleContext<BooleanLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(ITVScriptingParser.StringLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeLiteralContext typeLiteral() {
			return GetRuleContext<TypeLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NumericLiteralContext numericLiteral() {
			return GetRuleContext<NumericLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RefLiteralContext refLiteral() {
			return GetRuleContext<RefLiteralContext>(0);
		}
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 80, RULE_literal);
		try {
			State = 567;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,50,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 561;
				nullLiteral();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 562;
				booleanLiteral();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 563;
				Match(StringLiteral);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 564;
				typeLiteral();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 565;
				numericLiteral();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 566;
				refLiteral();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumericLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DecimalLiteral() { return GetToken(ITVScriptingParser.DecimalLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HexIntegerLiteral() { return GetToken(ITVScriptingParser.HexIntegerLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OctalIntegerLiteral() { return GetToken(ITVScriptingParser.OctalIntegerLiteral, 0); }
		public NumericLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numericLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumericLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumericLiteralContext numericLiteral() {
		NumericLiteralContext _localctx = new NumericLiteralContext(Context, State);
		EnterRule(_localctx, 82, RULE_numericLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 569;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 68)) & ~0x3f) == 0 && ((1L << (_la - 68)) & ((1L << (DecimalLiteral - 68)) | (1L << (HexIntegerLiteral - 68)) | (1L << (OctalIntegerLiteral - 68)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(ITVScriptingParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ReservedWordContext reservedWord() {
			return GetRuleContext<ReservedWordContext>(0);
		}
		public IdentifierNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifierName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierNameContext identifierName() {
		IdentifierNameContext _localctx = new IdentifierNameContext(Context, State);
		EnterRule(_localctx, 84, RULE_identifierName);
		try {
			State = 573;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 571;
				Match(Identifier);
				}
				break;
			case T__11:
			case T__13:
			case T__14:
			case T__15:
			case Break:
			case Do:
			case Case:
			case Else:
			case New:
			case Catch:
			case Finally:
			case Return:
			case Continue:
			case For:
			case Switch:
			case While:
			case Function:
			case Default:
			case If:
			case Throw:
			case In:
			case Try:
			case Has:
			case Is:
				EnterOuterAlt(_localctx, 2);
				{
				State = 572;
				reservedWord();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReservedWordContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public KeywordContext keyword() {
			return GetRuleContext<KeywordContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NullLiteralContext nullLiteral() {
			return GetRuleContext<NullLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BooleanLiteralContext booleanLiteral() {
			return GetRuleContext<BooleanLiteralContext>(0);
		}
		public ReservedWordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reservedWord; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReservedWord(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReservedWordContext reservedWord() {
		ReservedWordContext _localctx = new ReservedWordContext(Context, State);
		EnterRule(_localctx, 86, RULE_reservedWord);
		try {
			State = 580;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Break:
			case Do:
			case Case:
			case Else:
			case New:
			case Catch:
			case Finally:
			case Return:
			case Continue:
			case For:
			case Switch:
			case While:
			case Function:
			case Default:
			case If:
			case Throw:
			case In:
			case Try:
			case Has:
			case Is:
				EnterOuterAlt(_localctx, 1);
				{
				State = 575;
				keyword();
				}
				break;
			case T__11:
			case T__13:
			case T__14:
			case T__15:
				EnterOuterAlt(_localctx, 2);
				{
				State = 578;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case T__11:
				case T__15:
					{
					State = 576;
					nullLiteral();
					}
					break;
				case T__13:
				case T__14:
					{
					State = 577;
					booleanLiteral();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class KeywordContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Break() { return GetToken(ITVScriptingParser.Break, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Do() { return GetToken(ITVScriptingParser.Do, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Case() { return GetToken(ITVScriptingParser.Case, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Else() { return GetToken(ITVScriptingParser.Else, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode New() { return GetToken(ITVScriptingParser.New, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Catch() { return GetToken(ITVScriptingParser.Catch, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Finally() { return GetToken(ITVScriptingParser.Finally, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Return() { return GetToken(ITVScriptingParser.Return, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Continue() { return GetToken(ITVScriptingParser.Continue, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode For() { return GetToken(ITVScriptingParser.For, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Switch() { return GetToken(ITVScriptingParser.Switch, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode While() { return GetToken(ITVScriptingParser.While, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Function() { return GetToken(ITVScriptingParser.Function, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Default() { return GetToken(ITVScriptingParser.Default, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode If() { return GetToken(ITVScriptingParser.If, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Throw() { return GetToken(ITVScriptingParser.Throw, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode In() { return GetToken(ITVScriptingParser.In, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Try() { return GetToken(ITVScriptingParser.Try, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Has() { return GetToken(ITVScriptingParser.Has, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Is() { return GetToken(ITVScriptingParser.Is, 0); }
		public KeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keyword; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public KeywordContext keyword() {
		KeywordContext _localctx = new KeywordContext(Context, State);
		EnterRule(_localctx, 88, RULE_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 582;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 71)) & ~0x3f) == 0 && ((1L << (_la - 71)) & ((1L << (Break - 71)) | (1L << (Do - 71)) | (1L << (Case - 71)) | (1L << (Else - 71)) | (1L << (New - 71)) | (1L << (Catch - 71)) | (1L << (Finally - 71)) | (1L << (Return - 71)) | (1L << (Continue - 71)) | (1L << (For - 71)) | (1L << (Switch - 71)) | (1L << (While - 71)) | (1L << (Function - 71)) | (1L << (Default - 71)) | (1L << (If - 71)) | (1L << (Throw - 71)) | (1L << (In - 71)) | (1L << (Try - 71)) | (1L << (Has - 71)) | (1L << (Is - 71)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EosContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SemiColon() { return GetToken(ITVScriptingParser.SemiColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(ITVScriptingParser.Eof, 0); }
		public EosContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eos; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEos(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EosContext eos() {
		EosContext _localctx = new EosContext(Context, State);
		EnterRule(_localctx, 90, RULE_eos);
		try {
			State = 588;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,54,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 584;
				Match(SemiColon);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 585;
				Match(Eof);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 586;
				if (!(lineTerminatorAhead())) throw new FailedPredicateException(this, "lineTerminatorAhead()");
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 587;
				if (!(TokenStream.LT(1).Type == CloseBrace)) throw new FailedPredicateException(this, "TokenStream.LT(1).Type == CloseBrace");
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EofContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(ITVScriptingParser.Eof, 0); }
		public EofContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eof; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEof(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EofContext eof() {
		EofContext _localctx = new EofContext(Context, State);
		EnterRule(_localctx, 92, RULE_eof);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 590;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NullLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeLiteralContext typeLiteral() {
			return GetRuleContext<TypeLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(ITVScriptingParser.Dot, 0); }
		public NullLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nullLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNullLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NullLiteralContext nullLiteral() {
		NullLiteralContext _localctx = new NullLiteralContext(Context, State);
		EnterRule(_localctx, 94, RULE_nullLiteral);
		try {
			State = 597;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case T__11:
				EnterOuterAlt(_localctx, 1);
				{
				State = 592;
				Match(T__11);
				}
				break;
			case T__15:
				EnterOuterAlt(_localctx, 2);
				{
				State = 593;
				typeLiteral();
				State = 594;
				Match(Dot);
				State = 595;
				Match(T__11);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RefLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeLiteralContext typeLiteral() {
			return GetRuleContext<TypeLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(ITVScriptingParser.Dot, 0); }
		public RefLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_refLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRefLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RefLiteralContext refLiteral() {
		RefLiteralContext _localctx = new RefLiteralContext(Context, State);
		EnterRule(_localctx, 96, RULE_refLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 599;
			typeLiteral();
			State = 600;
			Match(Dot);
			State = 601;
			Match(T__12);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooleanLiteralContext : ParserRuleContext {
		public BooleanLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_booleanLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBooleanLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BooleanLiteralContext booleanLiteral() {
		BooleanLiteralContext _localctx = new BooleanLiteralContext(Context, State);
		EnterRule(_localctx, 98, RULE_booleanLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 603;
			_la = TokenStream.LA(1);
			if ( !(_la==T__13 || _la==T__14) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeLiteralIdentifierContext typeLiteralIdentifier() {
			return GetRuleContext<TypeLiteralIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeArgumentsContext typeArguments() {
			return GetRuleContext<TypeArgumentsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(ITVScriptingParser.StringLiteral, 0); }
		public TypeLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeLiteralContext typeLiteral() {
		TypeLiteralContext _localctx = new TypeLiteralContext(Context, State);
		EnterRule(_localctx, 100, RULE_typeLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 605;
			Match(T__15);
			State = 606;
			typeLiteralIdentifier();
			State = 608;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==T__2 || _la==LessThan) {
				{
				State = 607;
				typeArguments();
				}
			}

			State = 612;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==T__16) {
				{
				State = 610;
				Match(T__16);
				State = 611;
				Match(StringLiteral);
				}
			}

			State = 614;
			Match(T__15);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeLiteralIdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(ITVScriptingParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(ITVScriptingParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Dot() { return GetTokens(ITVScriptingParser.Dot); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot(int i) {
			return GetToken(ITVScriptingParser.Dot, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Plus() { return GetTokens(ITVScriptingParser.Plus); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus(int i) {
			return GetToken(ITVScriptingParser.Plus, i);
		}
		public TypeLiteralIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeLiteralIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IITVScriptingVisitor<TResult> typedVisitor = visitor as IITVScriptingVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeLiteralIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeLiteralIdentifierContext typeLiteralIdentifier() {
		TypeLiteralIdentifierContext _localctx = new TypeLiteralIdentifierContext(Context, State);
		EnterRule(_localctx, 102, RULE_typeLiteralIdentifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 616;
			Match(Identifier);
			State = 621;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Dot || _la==Plus) {
				{
				{
				State = 617;
				_la = TokenStream.LA(1);
				if ( !(_la==Dot || _la==Plus) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 618;
				Match(Identifier);
				}
				}
				State = 623;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 7: return expressionStatement_sempred((ExpressionStatementContext)_localctx, predIndex);
		case 38: return singleExpression_sempred((SingleExpressionContext)_localctx, predIndex);
		case 45: return eos_sempred((EosContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expressionStatement_sempred(ExpressionStatementContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return (TokenStream.LA(1) != OpenBrace) && (TokenStream.LA(1) != Function);
		}
		return true;
	}
	private bool singleExpression_sempred(SingleExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return Precpred(Context, 32);
		case 2: return Precpred(Context, 21);
		case 3: return Precpred(Context, 20);
		case 4: return Precpred(Context, 19);
		case 5: return Precpred(Context, 18);
		case 6: return Precpred(Context, 17);
		case 7: return Precpred(Context, 16);
		case 8: return Precpred(Context, 15);
		case 9: return Precpred(Context, 14);
		case 10: return Precpred(Context, 13);
		case 11: return Precpred(Context, 12);
		case 12: return Precpred(Context, 11);
		case 13: return Precpred(Context, 10);
		case 14: return Precpred(Context, 9);
		case 15: return Precpred(Context, 8);
		case 16: return Precpred(Context, 36);
		case 17: return Precpred(Context, 35);
		case 18: return Precpred(Context, 34);
		case 19: return Precpred(Context, 33);
		case 20: return Precpred(Context, 31);
		case 21: return Precpred(Context, 29);
		case 22: return !here(LineTerminator);
		case 23: return Precpred(Context, 28);
		case 24: return !here(LineTerminator);
		}
		return true;
	}
	private bool eos_sempred(EosContext _localctx, int predIndex) {
		switch (predIndex) {
		case 25: return lineTerminatorAhead();
		case 26: return TokenStream.LT(1).Type == CloseBrace;
		}
		return true;
	}

	private static int[] _serializedATN = {
		4,1,98,625,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,35,
		2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,42,
		2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,
		2,50,7,50,2,51,7,51,1,0,3,0,106,8,0,1,0,1,0,1,1,4,1,111,8,1,11,1,12,1,
		112,1,2,1,2,3,2,117,8,2,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,
		3,3,3,131,8,3,1,4,1,4,3,4,135,8,4,1,4,1,4,1,5,4,5,140,8,5,11,5,12,5,141,
		1,6,1,6,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,3,8,157,8,8,1,9,1,
		9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,
		1,9,1,9,1,9,1,9,1,9,1,9,3,9,184,8,9,1,9,1,9,3,9,188,8,9,1,9,1,9,3,9,192,
		8,9,1,9,1,9,3,9,196,8,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,
		10,3,10,208,8,10,1,11,1,11,1,11,1,12,1,12,1,12,1,13,1,13,3,13,218,8,13,
		1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,14,1,15,1,15,1,15,3,15,231,8,15,1,
		15,1,15,1,16,4,16,236,8,16,11,16,12,16,237,1,17,1,17,1,17,1,17,3,17,244,
		8,17,1,18,1,18,1,18,3,18,249,8,18,1,19,1,19,3,19,253,8,19,1,19,1,19,1,
		20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,3,20,270,
		8,20,1,21,1,21,1,21,1,21,1,21,1,21,1,22,1,22,1,22,1,23,1,23,1,23,1,23,
		3,23,285,8,23,1,23,1,23,1,23,1,23,1,23,1,24,1,24,1,24,5,24,295,8,24,10,
		24,12,24,298,9,24,1,25,3,25,301,8,25,1,26,1,26,3,26,305,8,26,1,26,1,26,
		1,27,1,27,1,27,5,27,312,8,27,10,27,12,27,315,9,27,1,28,1,28,3,28,319,8,
		28,1,28,3,28,322,8,28,1,28,1,28,1,29,1,29,1,29,3,29,329,8,29,1,29,5,29,
		332,8,29,10,29,12,29,335,9,29,1,30,1,30,1,30,1,30,3,30,341,8,30,1,30,1,
		30,1,31,1,31,3,31,347,8,31,1,31,1,31,1,32,1,32,1,32,1,32,1,32,1,32,4,32,
		357,8,32,11,32,12,32,358,3,32,361,8,32,1,33,1,33,1,33,1,34,1,34,1,34,5,
		34,369,8,34,10,34,12,34,372,9,34,1,35,1,35,1,35,1,35,5,35,378,8,35,10,
		35,12,35,381,9,35,1,36,1,36,1,36,5,36,386,8,36,10,36,12,36,389,9,36,1,
		37,1,37,1,37,5,37,394,8,37,10,37,12,37,397,9,37,1,38,1,38,1,38,3,38,402,
		8,38,1,38,1,38,3,38,406,8,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,3,
		38,416,8,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,
		1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,
		1,38,3,38,459,8,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,
		38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,
		38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,
		38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,
		38,1,38,3,38,515,8,38,1,38,1,38,1,38,1,38,3,38,521,8,38,1,38,1,38,1,38,
		1,38,3,38,527,8,38,1,38,1,38,1,38,1,38,3,38,533,8,38,1,38,3,38,536,8,38,
		1,38,3,38,539,8,38,1,38,1,38,3,38,543,8,38,1,38,1,38,3,38,547,8,38,1,38,
		1,38,1,38,1,38,1,38,1,38,5,38,555,8,38,10,38,12,38,558,9,38,1,39,1,39,
		1,40,1,40,1,40,1,40,1,40,1,40,3,40,568,8,40,1,41,1,41,1,42,1,42,3,42,574,
		8,42,1,43,1,43,1,43,3,43,579,8,43,3,43,581,8,43,1,44,1,44,1,45,1,45,1,
		45,1,45,3,45,589,8,45,1,46,1,46,1,47,1,47,1,47,1,47,1,47,3,47,598,8,47,
		1,48,1,48,1,48,1,48,1,49,1,49,1,50,1,50,1,50,3,50,609,8,50,1,50,1,50,3,
		50,613,8,50,1,50,1,50,1,51,1,51,1,51,5,51,620,8,51,10,51,12,51,623,9,51,
		1,51,0,1,76,52,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
		40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,
		88,90,92,94,96,98,100,102,0,10,1,0,39,41,1,0,35,36,1,0,42,43,1,0,44,47,
		1,0,48,49,1,0,55,64,1,0,68,70,2,0,71,80,82,91,1,0,14,15,2,0,31,31,35,35,
		683,0,105,1,0,0,0,2,110,1,0,0,0,4,116,1,0,0,0,6,130,1,0,0,0,8,132,1,0,
		0,0,10,139,1,0,0,0,12,143,1,0,0,0,14,145,1,0,0,0,16,149,1,0,0,0,18,195,
		1,0,0,0,20,207,1,0,0,0,22,209,1,0,0,0,24,212,1,0,0,0,26,215,1,0,0,0,28,
		221,1,0,0,0,30,227,1,0,0,0,32,235,1,0,0,0,34,239,1,0,0,0,36,245,1,0,0,
		0,38,250,1,0,0,0,40,269,1,0,0,0,42,271,1,0,0,0,44,277,1,0,0,0,46,280,1,
		0,0,0,48,291,1,0,0,0,50,300,1,0,0,0,52,302,1,0,0,0,54,308,1,0,0,0,56,316,
		1,0,0,0,58,325,1,0,0,0,60,336,1,0,0,0,62,344,1,0,0,0,64,360,1,0,0,0,66,
		362,1,0,0,0,68,365,1,0,0,0,70,373,1,0,0,0,72,382,1,0,0,0,74,390,1,0,0,
		0,76,458,1,0,0,0,78,559,1,0,0,0,80,567,1,0,0,0,82,569,1,0,0,0,84,573,1,
		0,0,0,86,580,1,0,0,0,88,582,1,0,0,0,90,588,1,0,0,0,92,590,1,0,0,0,94,597,
		1,0,0,0,96,599,1,0,0,0,98,603,1,0,0,0,100,605,1,0,0,0,102,616,1,0,0,0,
		104,106,3,2,1,0,105,104,1,0,0,0,105,106,1,0,0,0,106,107,1,0,0,0,107,108,
		5,0,0,1,108,1,1,0,0,0,109,111,3,4,2,0,110,109,1,0,0,0,111,112,1,0,0,0,
		112,110,1,0,0,0,112,113,1,0,0,0,113,3,1,0,0,0,114,117,3,6,3,0,115,117,
		3,46,23,0,116,114,1,0,0,0,116,115,1,0,0,0,117,5,1,0,0,0,118,131,3,8,4,
		0,119,131,3,12,6,0,120,131,3,14,7,0,121,131,3,16,8,0,122,131,3,18,9,0,
		123,131,3,22,11,0,124,131,3,24,12,0,125,131,3,26,13,0,126,131,3,28,14,
		0,127,131,3,38,19,0,128,131,3,40,20,0,129,131,3,20,10,0,130,118,1,0,0,
		0,130,119,1,0,0,0,130,120,1,0,0,0,130,121,1,0,0,0,130,122,1,0,0,0,130,
		123,1,0,0,0,130,124,1,0,0,0,130,125,1,0,0,0,130,126,1,0,0,0,130,127,1,
		0,0,0,130,128,1,0,0,0,130,129,1,0,0,0,131,7,1,0,0,0,132,134,5,23,0,0,133,
		135,3,10,5,0,134,133,1,0,0,0,134,135,1,0,0,0,135,136,1,0,0,0,136,137,5,
		24,0,0,137,9,1,0,0,0,138,140,3,6,3,0,139,138,1,0,0,0,140,141,1,0,0,0,141,
		139,1,0,0,0,141,142,1,0,0,0,142,11,1,0,0,0,143,144,5,25,0,0,144,13,1,0,
		0,0,145,146,4,7,0,0,146,147,3,74,37,0,147,148,3,90,45,0,148,15,1,0,0,0,
		149,150,5,86,0,0,150,151,5,21,0,0,151,152,3,76,38,0,152,153,5,22,0,0,153,
		156,3,6,3,0,154,155,5,74,0,0,155,157,3,6,3,0,156,154,1,0,0,0,156,157,1,
		0,0,0,157,17,1,0,0,0,158,159,5,72,0,0,159,160,3,6,3,0,160,161,5,83,0,0,
		161,162,5,21,0,0,162,163,3,76,38,0,163,164,5,22,0,0,164,165,3,90,45,0,
		165,196,1,0,0,0,166,167,5,83,0,0,167,168,5,21,0,0,168,169,3,76,38,0,169,
		170,5,22,0,0,170,171,3,6,3,0,171,196,1,0,0,0,172,173,5,81,0,0,173,174,
		5,21,0,0,174,175,3,76,38,0,175,176,5,88,0,0,176,177,3,76,38,0,177,178,
		5,22,0,0,178,179,3,6,3,0,179,196,1,0,0,0,180,181,5,80,0,0,181,183,5,21,
		0,0,182,184,3,74,37,0,183,182,1,0,0,0,183,184,1,0,0,0,184,185,1,0,0,0,
		185,187,5,25,0,0,186,188,3,74,37,0,187,186,1,0,0,0,187,188,1,0,0,0,188,
		189,1,0,0,0,189,191,5,25,0,0,190,192,3,74,37,0,191,190,1,0,0,0,191,192,
		1,0,0,0,192,193,1,0,0,0,193,194,5,22,0,0,194,196,3,6,3,0,195,158,1,0,0,
		0,195,166,1,0,0,0,195,172,1,0,0,0,195,180,1,0,0,0,196,19,1,0,0,0,197,198,
		5,1,0,0,198,199,5,92,0,0,199,200,5,22,0,0,200,201,5,93,0,0,201,208,3,90,
		45,0,202,203,5,2,0,0,203,204,5,92,0,0,204,205,5,22,0,0,205,206,5,93,0,
		0,206,208,3,90,45,0,207,197,1,0,0,0,207,202,1,0,0,0,208,21,1,0,0,0,209,
		210,5,79,0,0,210,211,3,90,45,0,211,23,1,0,0,0,212,213,5,71,0,0,213,214,
		3,90,45,0,214,25,1,0,0,0,215,217,5,78,0,0,216,218,3,76,38,0,217,216,1,
		0,0,0,217,218,1,0,0,0,218,219,1,0,0,0,219,220,3,90,45,0,220,27,1,0,0,0,
		221,222,5,82,0,0,222,223,5,21,0,0,223,224,3,76,38,0,224,225,5,22,0,0,225,
		226,3,30,15,0,226,29,1,0,0,0,227,228,5,23,0,0,228,230,3,32,16,0,229,231,
		3,36,18,0,230,229,1,0,0,0,230,231,1,0,0,0,231,232,1,0,0,0,232,233,5,24,
		0,0,233,31,1,0,0,0,234,236,3,34,17,0,235,234,1,0,0,0,236,237,1,0,0,0,237,
		235,1,0,0,0,237,238,1,0,0,0,238,33,1,0,0,0,239,240,5,73,0,0,240,241,3,
		76,38,0,241,243,5,30,0,0,242,244,3,10,5,0,243,242,1,0,0,0,243,244,1,0,
		0,0,244,35,1,0,0,0,245,246,5,85,0,0,246,248,5,30,0,0,247,249,3,10,5,0,
		248,247,1,0,0,0,248,249,1,0,0,0,249,37,1,0,0,0,250,252,5,87,0,0,251,253,
		3,76,38,0,252,251,1,0,0,0,252,253,1,0,0,0,253,254,1,0,0,0,254,255,3,90,
		45,0,255,39,1,0,0,0,256,257,5,89,0,0,257,258,3,8,4,0,258,259,3,42,21,0,
		259,270,1,0,0,0,260,261,5,89,0,0,261,262,3,8,4,0,262,263,3,44,22,0,263,
		270,1,0,0,0,264,265,5,89,0,0,265,266,3,8,4,0,266,267,3,42,21,0,267,268,
		3,44,22,0,268,270,1,0,0,0,269,256,1,0,0,0,269,260,1,0,0,0,269,264,1,0,
		0,0,270,41,1,0,0,0,271,272,5,76,0,0,272,273,5,21,0,0,273,274,5,92,0,0,
		274,275,5,22,0,0,275,276,3,8,4,0,276,43,1,0,0,0,277,278,5,77,0,0,278,279,
		3,8,4,0,279,45,1,0,0,0,280,281,5,84,0,0,281,282,5,92,0,0,282,284,5,21,
		0,0,283,285,3,48,24,0,284,283,1,0,0,0,284,285,1,0,0,0,285,286,1,0,0,0,
		286,287,5,22,0,0,287,288,5,23,0,0,288,289,3,50,25,0,289,290,5,24,0,0,290,
		47,1,0,0,0,291,296,5,92,0,0,292,293,5,26,0,0,293,295,5,92,0,0,294,292,
		1,0,0,0,295,298,1,0,0,0,296,294,1,0,0,0,296,297,1,0,0,0,297,49,1,0,0,0,
		298,296,1,0,0,0,299,301,3,2,1,0,300,299,1,0,0,0,300,301,1,0,0,0,301,51,
		1,0,0,0,302,304,5,19,0,0,303,305,3,54,27,0,304,303,1,0,0,0,304,305,1,0,
		0,0,305,306,1,0,0,0,306,307,5,20,0,0,307,53,1,0,0,0,308,313,3,76,38,0,
		309,310,5,26,0,0,310,312,3,76,38,0,311,309,1,0,0,0,312,315,1,0,0,0,313,
		311,1,0,0,0,313,314,1,0,0,0,314,55,1,0,0,0,315,313,1,0,0,0,316,318,5,23,
		0,0,317,319,3,58,29,0,318,317,1,0,0,0,318,319,1,0,0,0,319,321,1,0,0,0,
		320,322,5,26,0,0,321,320,1,0,0,0,321,322,1,0,0,0,322,323,1,0,0,0,323,324,
		5,24,0,0,324,57,1,0,0,0,325,333,3,60,30,0,326,329,5,26,0,0,327,329,6,29,
		-1,0,328,326,1,0,0,0,328,327,1,0,0,0,329,330,1,0,0,0,330,332,3,60,30,0,
		331,328,1,0,0,0,332,335,1,0,0,0,333,331,1,0,0,0,333,334,1,0,0,0,334,59,
		1,0,0,0,335,333,1,0,0,0,336,340,3,84,42,0,337,341,5,30,0,0,338,339,5,27,
		0,0,339,341,6,30,-1,0,340,337,1,0,0,0,340,338,1,0,0,0,341,342,1,0,0,0,
		342,343,3,76,38,0,343,61,1,0,0,0,344,346,5,21,0,0,345,347,3,72,36,0,346,
		345,1,0,0,0,346,347,1,0,0,0,347,348,1,0,0,0,348,349,5,22,0,0,349,63,1,
		0,0,0,350,351,5,44,0,0,351,352,3,68,34,0,352,353,5,45,0,0,353,361,1,0,
		0,0,354,355,5,3,0,0,355,357,5,68,0,0,356,354,1,0,0,0,357,358,1,0,0,0,358,
		356,1,0,0,0,358,359,1,0,0,0,359,361,1,0,0,0,360,350,1,0,0,0,360,356,1,
		0,0,0,361,65,1,0,0,0,362,363,5,4,0,0,363,364,3,70,35,0,364,67,1,0,0,0,
		365,370,3,70,35,0,366,367,5,26,0,0,367,369,3,70,35,0,368,366,1,0,0,0,369,
		372,1,0,0,0,370,368,1,0,0,0,370,371,1,0,0,0,371,69,1,0,0,0,372,370,1,0,
		0,0,373,374,5,5,0,0,374,379,5,92,0,0,375,376,5,31,0,0,376,378,5,92,0,0,
		377,375,1,0,0,0,378,381,1,0,0,0,379,377,1,0,0,0,379,380,1,0,0,0,380,71,
		1,0,0,0,381,379,1,0,0,0,382,387,3,76,38,0,383,384,5,26,0,0,384,386,3,76,
		38,0,385,383,1,0,0,0,386,389,1,0,0,0,387,385,1,0,0,0,387,388,1,0,0,0,388,
		73,1,0,0,0,389,387,1,0,0,0,390,395,3,76,38,0,391,392,5,26,0,0,392,394,
		3,76,38,0,393,391,1,0,0,0,394,397,1,0,0,0,395,393,1,0,0,0,395,396,1,0,
		0,0,396,75,1,0,0,0,397,395,1,0,0,0,398,399,6,38,-1,0,399,401,5,84,0,0,
		400,402,5,92,0,0,401,400,1,0,0,0,401,402,1,0,0,0,402,403,1,0,0,0,403,405,
		5,21,0,0,404,406,3,48,24,0,405,404,1,0,0,0,405,406,1,0,0,0,406,407,1,0,
		0,0,407,408,5,22,0,0,408,409,5,23,0,0,409,410,3,50,25,0,410,411,5,24,0,
		0,411,459,1,0,0,0,412,413,5,75,0,0,413,415,3,76,38,0,414,416,3,64,32,0,
		415,414,1,0,0,0,415,416,1,0,0,0,416,417,1,0,0,0,417,418,3,62,31,0,418,
		459,1,0,0,0,419,420,5,33,0,0,420,459,3,76,38,27,421,422,5,34,0,0,422,459,
		3,76,38,26,423,424,5,35,0,0,424,459,3,76,38,25,425,426,5,36,0,0,426,459,
		3,76,38,24,427,428,5,37,0,0,428,459,3,76,38,23,429,430,5,38,0,0,430,459,
		3,76,38,22,431,459,5,92,0,0,432,459,3,80,40,0,433,459,3,52,26,0,434,459,
		3,56,28,0,435,436,5,21,0,0,436,437,3,76,38,0,437,438,5,22,0,0,438,459,
		1,0,0,0,439,440,5,7,0,0,440,441,3,76,38,0,441,442,5,8,0,0,442,443,5,92,
		0,0,443,444,5,4,0,0,444,445,5,92,0,0,445,446,5,22,0,0,446,447,5,9,0,0,
		447,448,3,76,38,0,448,449,5,10,0,0,449,450,3,76,38,2,450,459,1,0,0,0,451,
		452,5,11,0,0,452,453,5,92,0,0,453,454,5,22,0,0,454,455,5,9,0,0,455,456,
		5,94,0,0,456,457,5,10,0,0,457,459,3,76,38,1,458,398,1,0,0,0,458,412,1,
		0,0,0,458,419,1,0,0,0,458,421,1,0,0,0,458,423,1,0,0,0,458,425,1,0,0,0,
		458,427,1,0,0,0,458,429,1,0,0,0,458,431,1,0,0,0,458,432,1,0,0,0,458,433,
		1,0,0,0,458,434,1,0,0,0,458,435,1,0,0,0,458,439,1,0,0,0,458,451,1,0,0,
		0,459,556,1,0,0,0,460,461,10,32,0,0,461,462,5,91,0,0,462,555,3,76,38,33,
		463,464,10,21,0,0,464,465,7,0,0,0,465,555,3,76,38,22,466,467,10,20,0,0,
		467,468,7,1,0,0,468,555,3,76,38,21,469,470,10,19,0,0,470,471,7,2,0,0,471,
		555,3,76,38,20,472,473,10,18,0,0,473,474,7,3,0,0,474,555,3,76,38,19,475,
		476,10,17,0,0,476,477,7,4,0,0,477,555,3,76,38,18,478,479,10,16,0,0,479,
		480,5,50,0,0,480,555,3,76,38,17,481,482,10,15,0,0,482,483,5,51,0,0,483,
		555,3,76,38,16,484,485,10,14,0,0,485,486,5,52,0,0,486,555,3,76,38,15,487,
		488,10,13,0,0,488,489,5,53,0,0,489,555,3,76,38,14,490,491,10,12,0,0,491,
		492,5,54,0,0,492,555,3,76,38,13,493,494,10,11,0,0,494,495,5,28,0,0,495,
		555,3,76,38,12,496,497,10,10,0,0,497,498,5,29,0,0,498,499,3,76,38,0,499,
		500,5,30,0,0,500,501,3,76,38,11,501,555,1,0,0,0,502,503,10,9,0,0,503,504,
		5,27,0,0,504,555,3,76,38,10,505,506,10,8,0,0,506,507,3,78,39,0,507,508,
		3,76,38,9,508,555,1,0,0,0,509,510,10,36,0,0,510,511,5,19,0,0,511,512,3,
		74,37,0,512,514,5,20,0,0,513,515,3,66,33,0,514,513,1,0,0,0,514,515,1,0,
		0,0,515,555,1,0,0,0,516,517,10,35,0,0,517,518,5,6,0,0,518,520,3,84,42,
		0,519,521,3,66,33,0,520,519,1,0,0,0,520,521,1,0,0,0,521,555,1,0,0,0,522,
		523,10,34,0,0,523,524,5,31,0,0,524,526,3,84,42,0,525,527,3,66,33,0,526,
		525,1,0,0,0,526,527,1,0,0,0,527,555,1,0,0,0,528,529,10,33,0,0,529,530,
		5,90,0,0,530,532,3,84,42,0,531,533,3,64,32,0,532,531,1,0,0,0,532,533,1,
		0,0,0,533,535,1,0,0,0,534,536,3,62,31,0,535,534,1,0,0,0,535,536,1,0,0,
		0,536,538,1,0,0,0,537,539,3,66,33,0,538,537,1,0,0,0,538,539,1,0,0,0,539,
		555,1,0,0,0,540,542,10,31,0,0,541,543,3,64,32,0,542,541,1,0,0,0,542,543,
		1,0,0,0,543,544,1,0,0,0,544,546,3,62,31,0,545,547,3,66,33,0,546,545,1,
		0,0,0,546,547,1,0,0,0,547,555,1,0,0,0,548,549,10,29,0,0,549,550,4,38,22,
		0,550,555,5,33,0,0,551,552,10,28,0,0,552,553,4,38,24,0,553,555,5,34,0,
		0,554,460,1,0,0,0,554,463,1,0,0,0,554,466,1,0,0,0,554,469,1,0,0,0,554,
		472,1,0,0,0,554,475,1,0,0,0,554,478,1,0,0,0,554,481,1,0,0,0,554,484,1,
		0,0,0,554,487,1,0,0,0,554,490,1,0,0,0,554,493,1,0,0,0,554,496,1,0,0,0,
		554,502,1,0,0,0,554,505,1,0,0,0,554,509,1,0,0,0,554,516,1,0,0,0,554,522,
		1,0,0,0,554,528,1,0,0,0,554,540,1,0,0,0,554,548,1,0,0,0,554,551,1,0,0,
		0,555,558,1,0,0,0,556,554,1,0,0,0,556,557,1,0,0,0,557,77,1,0,0,0,558,556,
		1,0,0,0,559,560,7,5,0,0,560,79,1,0,0,0,561,568,3,94,47,0,562,568,3,98,
		49,0,563,568,5,93,0,0,564,568,3,100,50,0,565,568,3,82,41,0,566,568,3,96,
		48,0,567,561,1,0,0,0,567,562,1,0,0,0,567,563,1,0,0,0,567,564,1,0,0,0,567,
		565,1,0,0,0,567,566,1,0,0,0,568,81,1,0,0,0,569,570,7,6,0,0,570,83,1,0,
		0,0,571,574,5,92,0,0,572,574,3,86,43,0,573,571,1,0,0,0,573,572,1,0,0,0,
		574,85,1,0,0,0,575,581,3,88,44,0,576,579,3,94,47,0,577,579,3,98,49,0,578,
		576,1,0,0,0,578,577,1,0,0,0,579,581,1,0,0,0,580,575,1,0,0,0,580,578,1,
		0,0,0,581,87,1,0,0,0,582,583,7,7,0,0,583,89,1,0,0,0,584,589,5,25,0,0,585,
		589,5,0,0,1,586,589,4,45,25,0,587,589,4,45,26,0,588,584,1,0,0,0,588,585,
		1,0,0,0,588,586,1,0,0,0,588,587,1,0,0,0,589,91,1,0,0,0,590,591,5,0,0,1,
		591,93,1,0,0,0,592,598,5,12,0,0,593,594,3,100,50,0,594,595,5,31,0,0,595,
		596,5,12,0,0,596,598,1,0,0,0,597,592,1,0,0,0,597,593,1,0,0,0,598,95,1,
		0,0,0,599,600,3,100,50,0,600,601,5,31,0,0,601,602,5,13,0,0,602,97,1,0,
		0,0,603,604,7,8,0,0,604,99,1,0,0,0,605,606,5,16,0,0,606,608,3,102,51,0,
		607,609,3,64,32,0,608,607,1,0,0,0,608,609,1,0,0,0,609,612,1,0,0,0,610,
		611,5,17,0,0,611,613,5,93,0,0,612,610,1,0,0,0,612,613,1,0,0,0,613,614,
		1,0,0,0,614,615,5,16,0,0,615,101,1,0,0,0,616,621,5,92,0,0,617,618,7,9,
		0,0,618,620,5,92,0,0,619,617,1,0,0,0,620,623,1,0,0,0,621,619,1,0,0,0,621,
		622,1,0,0,0,622,103,1,0,0,0,623,621,1,0,0,0,59,105,112,116,130,134,141,
		156,183,187,191,195,207,217,230,237,243,248,252,269,284,296,300,304,313,
		318,321,328,333,340,346,358,360,370,379,387,395,401,405,415,458,514,520,
		526,532,535,538,542,546,554,556,567,573,578,580,588,597,608,612,621
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace ITVComponents.Scripting.CScript.Core
